
		TOPPERS/HRMP3カーネル
		設計メモ

		対応バージョン: Release 3.3.1
		最終更新: 2020年10月11日

このメモは，TOPPERS/HRMPカーネル（以下，HRMP3カーネルと呼ぶ）の設計に
関するメモである。設計の妥当性を確認することを目的に，コードを分析する
形で作成したものである。

○目次

・排他制御の設計
	- 基本方針
	- CPUロックとジャイアントロック
・自プロセッサの状態の取得
	- 自プロセッサのPCBへのポインタの取得
	- 自プロセッサのPCB中のフィールドへのアクセス
	- sense_contextとsense_lock
	- サービスコールの静的エラーのチェック
	- CPUロック状態の一時解除に関する分析
・データ構造のアクセス元と排他制御
	- グローバル変数
	- プロセッサ管理ブロック（PCB）
	- タスク管理ブロック（TCB）
・サービスコールからのディスパッチ処理
・タスクのマイグレート処理
	- mig_tskによるタスクのマイグレート
	- mact_tskによるタスクのマイグレート
・タスクの待ち情報の持ち方
・スピンロック機能の実現
	- ネイティブスピンロックとエミュレーションによる実現
	- スピンロック初期化ブロック
	- スピンロックの自動解放
	- スピンロック機能とCPUロック状態の管理
・プロセッサ間割込みの優先度


○排他制御の設計

●基本方針

マルチプロセッサ対応カーネルでは，プロセッサ内での排他制御と，プロセッ
サ間での排他制御を考える必要がある。

HRMP3カーネルでは，OSのデータ構造に対するプロセッサ内での排他制御は，
ASP3/HRP3カーネルと同様に，CPUロック（または割込みロック）により実現す
る。プロセッサ間での排他制御は，FMP3カーネルと同様に，スピンロックを1
つだけ用いるジャイアントロック方式で実現する。

ASP3/HRP3カーネルでは，サービスコールの処理に加えて，タスクディスパッ
チ処理や割込み／例外の出入口処理（の一部）もクリティカルセクションと位
置付け，CPUロック状態（または割込みロック状態）で実行している。FMP3/
HRMP3カーネルでは，プロセッサ内の排他制御についてはこの方針を踏襲する
が，プロセッサ間の排他制御については，ジャイアントロック待ち時間をでき
る限り短くするために，タスクディスパッチ処理や割込み／例外の出入口処理
はクリティカルセクション外とする。すなわち，タスクディスパッチ処理や割
込み／例外の出入口処理は，ジャイアントロックを取得しない状態で実行する。
言い換えると，あるプロセッサでのタスクディスパッチや割込み／例外の出入
りは，他のプロセッサと同期せずに実行される。

この方針から，タスクディスパッチ処理や割込み／例外の出入口処理でアクセ
スするデータ構造は，1つのプロセッサのみからアクセスすることを原則とす
る。複数のプロセッサからアクセスする場合には，問題ないかどうかを個別に
検討する。この制約から，mig_tsk，ras_ter，ter_tskの3つのサービスコール
において，対象タスクを，自タスクと同じプロセッサに割り付けられているタ
スクに限る仕様としている［NGKI1157］［NGKI3481］［NGKI1182］。

タスクディスパッチ処理や割込み／例外の出入口処理でアクセスするデータ構
造（RAMに置かれるもの）は，以下の通りである。
	
	自プロセッサのプロセッサ管理ブロック（PCB）中の次のフィールド
		p_runtsk			リード／ライト
		p_schedtsk			リード
		p_ctxdom			リード／ライト
		twdtimer_enable		リード
		rundom				リード／ライト
		left_twdtim			リード／ライト
		twdtimer_flag		リード／ライト

		＊ARMターゲット依存
		excpt_nest_count	リード／ライト
		istkpt				リード
		idstkpt				リード
		p_exc_tbl			リード
		p_inh_tbl			リード

	自タスクのTCB中の次のフィールド
		p_tinib				リード
		p_dominib			リード
		tskctxb				リード／ライト

		＊オーバランハンドラ拡張の場合（HRMP3は未サポート）
		staovr				リード
        leftotm				リード／ライト

	自タスクのシステムスタック領域		リード／ライト

この中で，p_tinibとp_dominibは，OS初期化時に初期化された後，書き換えら
れないため，排他制御は必要ない。p_runtskとp_schedtskは，複数のプロセッ
サからアクセスされるため，個別に検討することが必要である。その他のデー
タ構造は，PCB中のフィールドについては当該プロセッサ，TCB中のフィールド
とシステムスタック領域については，当該タスクが割り付けられているプロセッ
サのみがアクセスするため，プロセッサ間の排他制御は必要ない。

●CPUロックとジャイアントロック

割込み応答性の向上とジャイアントロックの保持時間の短縮を両立させるため
に，割込み禁止とジャイアントロックの取得は不可分に行うようにする。具体
的には，ジャイアントロック待ちの間に割込み要求があった場合には割込みを
受け付け，ジャイアントロックを取得した後は割込みを受け付けないようにす
る。

これを実現するために，ジャイアントロックを取得する関数acquire_glockは，
ジャイアントロックの取得を待ってループしている間に，CPUロック状態を解
除して割込み要求を受け付ける（割込み要求があった場合のみ，CPUロック状
態を解除する方法でも良い）。なお，acquire_glockは，CPUロック状態で呼び
出すものとする。

acquire_glockを，Test&Setロックで実現した場合のコード例を以下に示す。

----------------------------------------
Inline void
acquire_glock(void)
{
	while (test_and_set(giant_lock)) {
		unlock_cpu();
		delay_for_interrupt();
		lock_cpu();
	}
	Asm("":::"memory");			/* 最適化の抑止 */
}
----------------------------------------

CPUロック解除状態で呼ばれたサービスコール中で，プロセッサ内およびプロ
セッサ間の排他制御のために，CPUロック状態かつジャイアントロック取得状
態にしたい場合には，lock_cpu（または，lock_cpu_dsp）に続けて
acquire_glockを呼び出せば良い。

----------------------------------------
	lock_cpu();
	acquire_glock();
----------------------------------------

ジャイアントロックを取得する必要のあるサービスコールのほとんどは，CPU
ロック状態で呼ぶことができない（呼ぶとエラーになる）ため，この方法を用
いる。

一方，CPUロック状態で呼び出すことができ，ジャイアントロックを取得する
必要があるサービスコールは，この方法を用いることができない。これに当て
はまる唯一のサービスコールとして，ext_tskがある。ext_tskがCPUロック状
態で呼ばれた場合に，サービスコール内でacquire_glockを呼ぶと，CPUロック
状態が解除されてしまい，カーネル処理の不可分性の原則をみたせなくなる。
この問題を解決する方法として，次の2つが考えられる。

(1) CPUロック状態を解除せずにジャイアントロックを取得する関数を用意し，
	ext_tsk内ではそれを用いる。ただし，この方法には，割込み禁止時間が
	長くなるという問題がある。

(2) CPUロック状態で呼ばれたext_tskを，カーネル処理の不可分性の原則の例
	外とする。

HRMP3カーネルでは，最大割込み禁止時間を短くするために，(2)の方法を採用
する。このことは，統合仕様書にも記載している［NGKI5183］［NGKI0648］。
ext_tskがCPUロック状態で呼べるのは，あくまでも誤用からのリカバリのため
であり，その時に不可分性の原則が崩れるのは大きい問題ではないと考えた。

一方，CPUロック状態で呼ぶことができるその他のサービスコールは，ジャイ
アントロックを取得する必要がない。具体的には，以下のサービスコールがこ
れに該当する。

	sns_ter
	unl_spn
	loc_cpu，unl_cpu
	sns_ctx，sns_loc，sns_dsp，sns_dpn
	sns_ker，ext_ker
	prb_mem，ref_mem
	dis_int，ena_int，clr_int，ras_int，prb_int


○自プロセッサの状態の取得

●自プロセッサのPCBへのポインタの取得

マルチプロセッサ対応カーネルでは，プロセッサ毎に管理すべき情報が多数あ
るため，プロセッサに関連する情報をまとめたデータ構造として，プロセッサ
管理ブロック（PCB）を用意する。

カーネルの中では，特に，処理単位を実行しているプロセッサ（これを，自プ
ロセッサと呼ぶ）のPCBに頻繁にアクセスするため，自プロセッサのPCBに効率
的にアクセスできることが望ましい。

カーネル内では，自プロセッサのPCBへのポインタを取得する関数として，
get_my_pcbを用いる。また，get_my_pcbのオーバヘッドが大きいターゲットが
あることを想定し，自プロセッサのPCBに複数回アクセスする場合には，
get_my_pcbで取り出した自プロセッサのPCBへのポインタをp_my_pcbという名
称のローカル変数に格納し，繰り返し使うようにする。さらに，p_my_pcbを使
用するカーネル内部関数には，p_my_pcbを第1パラメータに渡す。これにより，
get_my_pcbを呼び出すのは，以下の処理に限られる。

	- サービスコール処理関数（サービスコールの本体）
	- 静的エラーチェック用の関数（後述）
	- 割込み処理関数
	- set_hrt_event … 例外として認める
	- コンフィギュレータが生成する割込みハンドラ
	- ターゲット依存部

マルチプロセッサシステムでは，少なくとも，自プロセッサの番号を取り出す
機能は備えられていることから，自プロセッサの番号を取り出して，そこから
自プロセッサのPCBへのポインタを計算する方法が基本となる。これを実現す
るために，自プロセッサの番号を0オリジンで取得する関数get_my_prcidxを，
ターゲット依存部で用意することとする。これを用いて，ターゲット非依存部
で，get_my_pcbを次のように定義する。

----------------------------------------
#ifndef get_my_pcb
#define get_my_pcb()		(_kernel_p_pcb_table[get_my_prcidx()])
#endif /* get_my_pcb */
----------------------------------------

プロセッサ毎の識別番号を格納できる特殊レジスタ（例えば，ARMのスレッド
IDレジスタ）を備えるターゲットでは，その特殊レジスタに自プロセッサの
PCBへのポインタを格納する。この場合には，ターゲット依存部でget_my_pcb
をマクロ定義する（マクロで定義しないと，ターゲット非依存部の定義が無効
にならない）。

また，プロセッサ毎に持つプライベートメモリ（他のプロセッサからはアクセ
スできないメモリ）に，各プロセッサから同じ番地でアクセスできるターゲッ
トでは，プライベートメモリに置いた変数に自プロセッサのPCBへのポインタ
を格納し，get_my_pcbは，その変数を読み出すように実装する方法も考えられ
る。

●自プロセッサのPCB中のフィールドへのアクセス

タスクコンテキストから，自プロセッサのPCBのフィールドにアクセスする時
には，タスクがマイグレートする可能性を考慮することが必要である。具体的
には，get_my_pcbで自プロセッサのPCBへのポインタを取得した後に，タスク
がマイグレートすると，取得したポインタが指すのが自プロセッサのPCBでな
くなってしまう。これを防ぐには，自プロセッサのPCBへのポインタを取得し
た後，PCBのフィールドにアクセスする間，タスクがマイグレートするのを抑
止する必要がある。そのためには，タスクディスパッチ保留状態にするのが簡
単であり，HRMP3カーネルにおいては，CPUロック状態にすることにより，タス
クマイグレーションを抑止するのを基本とする。

すなわち，CPUロック状態（一般にはタスクディスパッチ保留状態）にした後，
get_my_pcbで自プロセッサのPCBへのポインタ（p_my_pcb）を取得し，
p_my_pcbは，CPUロック状態（一般にはタスクディスパッチ保留状態）である
間のみで使うのが基本である。

サービスコールの本体（クリティカルセクション内）でPCB中のフィールドに
アクセスする時は，原則として，CPUロック状態にした後（ジャイアントロッ
クを取る必要があるサービスコールの場合は，さらにジャイアントロックを取
得した状態にした後），get_my_pcbでp_my_pcbを取得し，CPUロック状態を解
除するまでの間のみp_my_pcbを使うこととする。

以下のサービスコールは，この原則の例外となっている。

・ext_ker，sns_ker
	CPUロック状態の代わりに，割込みロック状態を使っている。

・xsns_dpn，unl_cpu
	get_my_pcbでp_my_pcbを取得するのは，非タスクコンテキストから呼ばれ
	た場合のみであるため，問題ない。

・get_pid
	このサービスコールを実行中にタスクがマイグレートした場合，マイグレー
	ト前の値を返しても良い（統合仕様書には，使用上の注意として記載して
	いる）ため，問題ない。

また，サービスコールの処理の途中でCPUロック状態を一時的に解錠する場合
については，「CPUロック状態の一時解除に関する分析」の節で述べる。

それに対して，サービスコールの入口（クリティカルセクションに入る前）の
静的エラーのチェック部分で，PCB中のフィールドにアクセスする時が問題に
なる。具体的には，静的エラーのチェックに，p_runtsk，dspflg，rundomを参
照する必要がある。この課題については，「サービスコールの静的エラーの
チェック」の節で検討する。さらに，ターゲット依存部で，コンテキストや
CPUロック状態を判別するフィールドを参照する場合もある。この課題につい
ては，「sense_contextとsense_lock」の節で検討する。

ここで，静的エラーのチェックで参照する情報は，ある処理単位から参照した
場合に，自分で書き換える場合を除いては，変化しない（そのため，クリティ
カルセクション外でエラーチェックすることができる）ことに留意すること。

●sense_contextとsense_lock

実行中の処理単位のコンテキストとCPUロック状態を参照するカーネル内部の
関数として，sense_contextとsense_lockがある。コンテキストとCPUロック状
態の最適な管理方法は，プロセッサ毎に異なるため，これらの関数はターゲッ
ト依存部で定義することとしている。

コンテキストとCPUロック状態を，プロセッサ内の特殊レジスタで管理できる
場合には問題ないが，それらの管理に変数を用いる場合，プロセッサ毎に変数
を持つ必要があることから，ASP3/HRP3カーネルのようにグローバル変数を用
いることはできず，PCB中のターゲット依存部（target_pcb）に入れることが
必要である。

このような状況を想定して，sense_contxtには，自プロセッサのPCBへのポイ
ンタを渡す仕様とする。

	bool_t sense_context(PCB *p_my_pcb)

タスクコンテキストから，自プロセッサのPCBのフィールドにアクセスする時
には，前述の通り，タスクがマイグレートする可能性を考慮することが必要で
ある。具体的には，get_my_pcbによる自プロセッサのPCBへのポインタの取得
から，sense_contextを呼ぶまでを，CPUロック状態（または割込みロック状態）
にする必要がある。

割込みハンドラの先頭で，

	assert(sense_context(p_my_pcb)

を実行しているのは，これがタスクから呼ばれたものでないことを確認するた
めであるが，CPUロック状態にせずに呼んでおり，タスクから呼ばれた場合に
は，この原則の例外となっている。ただし，assertで不具合を見逃すことはあっ
ても，正しく動作しているのを不具合と判定することはないため，許容するこ
ととする。

同様のことは，sense_lockに対しても当てはまるが，sense_lockはCPUロック
状態であるかどうかを返す関数であり，CPUロック状態にしてからsense_lock
を呼ぶのは無意味である。そこで，sense_lockには自プロセッサのPCBへのポ
インタを渡さず，タスクがマイグレートする可能性の考慮は，ターゲット依存
部に委ねる方針とする。

	bool_t sense_lock()

なお，前述した，プロセッサ毎に持つプライベートメモリに各プロセッサから
同じ番地でアクセスできるターゲットでは，コンテキストとCPUロック状態を
管理するためにプロセッサ毎に持つ変数をプライベートメモリに置くことで，
これらの実装をシンプルにすることができる。

●サービスコールの静的エラーのチェック

多くのサービスコールは，最初に，呼出しコンテキストとCPUロック状態に関
するエラーチェックを行う。サービスコールによっては，クリティカルセクショ
ンに入る前に，さらに，ディスパッチ保留状態でないかのチェックや，呼出し
コンテキストに依存した処理を行う。前項までで述べた通り，これらの処理の
最適な方法はターゲットによって異なるため，ターゲット非依存部では標準的
な方法で実装しつつ，ターゲット依存部で最適化できるような設計を目指す。

ここでは，典型的な例として，タスクコンテキスト・CPUロック解除状態から
呼び出されたかをチェックするCHECK_TSKCTX_UNLを例に検討する。

まず，ASP3/HRP3カーネルにおけるCHECK_TSKCTX_UNLの定義は次の通りである。

----------------------------------------
#define CHECK_TSKCTX_UNL() do {								\
	if (sense_context() || sense_lock()) {					\
		ercd = E_CTX;										\
		goto error_exit;									\
	}														\
} while (false)
----------------------------------------

HRMP3カーネルでは，まず，if文の中を1つの関数check_tskctx_unlに置き換え
る。

----------------------------------------
#define CHECK_TSKCTX_UNL() do {								\
	if (check_tskctx_unl()) {								\
		ercd = E_CTX;										\
		goto error_exit;									\
	}														\
} while (false)
----------------------------------------

check_tskctx_unlのような関数を，静的エラーチェック用の関数と呼び，ター
ゲット非依存部には標準的な定義を含め，ターゲット依存部で置き換えられる
ようにする。check_tskctx_unlの標準的な定義は次の通り。

----------------------------------------
#ifndef OMIT_CHECK_TSKCTX_UNL

Inline bool_t
check_tskctx_unl(void)
{
	bool_t	context;
	SIL_PRE_LOC;

	SIL_LOC_INT();
	context = sense_context(get_my_pcb());
	SIL_UNL_INT();
	return(context || sense_lock());
}

#endif /* OMIT_CHECK_TSKCTX_UNL */
----------------------------------------

check_tskctx_unlは，ターゲット依存部で定義することで，次のような最適化
を行える可能性がある。コンテキストがプロセッサ内の特殊レジスタで判別で
きる場合には，sense_contextは自プロセッサのPCBへのポインタを使わず，割
込みを禁止して呼び出す必要がないため，get_my_pcbの呼出しと，割込みロッ
ク状態にする処理を省くことができる。逆に，sense_lockが自プロセッサの
PCBにアクセスする必要がある場合には，1回の割込みロックでsense_context
とsense_lockの両方を呼び出した方が効率的である。

サービスコールの最初で，呼出しコンテキストとCPUロック状態に関するエラー
チェックを行った後に，多くのサービスコールで，自タスクのTCBへのポイン
タや実行中の保護ドメインのビットパターンを参照することを必要とする。こ
れらの情報は，自プロセッサのPCB中に置かれているが，それにアクセするた
めには，割込みを禁止しなければならない。そのため，単純に実装すると，割
込みを禁止・許可を何度も繰り返すことになる。これを避けるために，静的エ
ラーチェック用の関数で，これらの情報も取り出すようにする。

上で例示したCHECK_TSKCTX_UNLに対しては，自タスクのTCBへのポインタと自
保護ドメインのビットパターンを取り出すCHECK_TSKCTX_UNL_MYSTATEを用意す
る。CHECK_TSKCTX_UNL_MYSTATEと，それが呼び出す静的エラーチェック用の関
数check_tskctx_unl_mystateの標準的な定義は次の通り。

----------------------------------------
#ifndef OMIT_CHECK_TSKCTX_UNL_MYSTATE

Inline bool_t
check_tskctx_unl_mystate(TCB **pp_selftsk, ACPTN *p_selfdom)
{
	bool_t	context;
	PCB		*p_my_pcb;
	SIL_PRE_LOC;

	SIL_LOC_INT();
	p_my_pcb = get_my_pcb();
	context = sense_context(p_my_pcb);
	*pp_selftsk = p_my_pcb->p_runtsk;
	*p_selfdom = p_my_pcb->rundom;
	SIL_UNL_INT();
	return(context || sense_lock());
}

#endif /* OMIT_CHECK_TSKCTX_UNL_MYSTATE */

#define CHECK_TSKCTX_UNL_MYSTATE(pp_selftsk, p_selfdom) do {	\
	if (check_tskctx_unl_mystate(pp_selftsk, p_selfdom)) {		\
		ercd = E_CTX;											\
		goto error_exit;										\
	}															\
} while (false)
----------------------------------------

なお，サービスコールによっては，自タスクのTCBへのポインタと実行中の保
護ドメインのビットパターンのどちらかしか必要としない。そのため，片方の
みを取り出すエラーチェックマクロおよび静的エラーチェック用の関数を用意
する手も考えられるが，バリエーションが多くなることから，コンパイラの最
適化により不要な方は消えることを期待して，両方を取り出すエラーチェック
マクロおよび静的エラーチェック用の関数のみを用意する。

HRMP3カーネルで用意しているこの種のエラーチェックマクロおよび静的エラー
チェック用の関数は次の通り。

	エラーチェックマクロ		静的エラーチェック用の関数
	------------------------------------------------------
	CHECK_TSKCTX				check_tskctx
	CHECK_TSKCTX_MYSTATE		check_tskctx_mystate
	CHECK_UNL					−
	CHECK_UNL_MYSTATE			check_unl_mystate
	CHECK_TSKCTX_UNL			check_tskctx_unl
	CHECK_TSKCTX_UNL_MYSTATE	check_tskctx_unl_mystate
	CHECK_DISPATCH				check_dispatch
	CHECK_DISPATCH_MYSTATE		check_dispatch_mystate

なお，CHECK_UNLに対応する静的エラーチェック用の関数は，sense_lockと同
じものになるため，用意していない。また，CHECK_TSKCTX_UNLと
check_tskctx_unlは，用意しているが，実際には用いていない（使用するサー
ビスコールがない）。

この他に，静的エラーチェック用の関数として，ディスパッチ禁止状態をチェッ
クするcheck_disdsp，自タスクのTCBへのポインタを取得するget_p_selftsk，
実行中の保護ドメインのビットパターンを取得するget_selfdomを用意してい
る。

ターゲット依存部で最適化のために用意すべき静的エラーチェック用の関数の
仕様については，「ターゲット依存部 ポーティングガイド」を参照すること。

●CPUロック状態の一時解除に関する分析

HRMP3カーネル内には，CPUロック状態が長時間続かないように，CPUロック状
態を一時的に解除する状況がある。PCBのフィールドにアクセスする際に，CPU
ロック状態にすることによりタスクマイグレーションを抑止していることから，
CPUロック状態を一時解除する時には，タスクマイグレーションへの対策が必
要になる。

HRMP3カーネルにおいて，CPUロック状態を一時的に解除する状況は次の通り。

(a) システム周期が切り換わっていないプロセッサの待ち合わせ（scyc_start）
(b) タイムウィンドウ通知ハンドラを呼び出す時（twd_start）
(c) タイムアウトに伴う待ち解除時（wait_tmout，wait_tmout_ok）
(d) 周期通知ハンドラを呼び出す時（call_cyclic）
(e) アラーム通知ハンドラを呼び出す時（call_alarm）
(f) 割込みサービスルーチンを呼び出す時（kernel_cfg.c）
(g) スピンロック取得待ち中（loc_spn）
(h) ジャイアントロック取得待ち中（acquire_glock，ターゲット依存部）

この内，(f)の割込みサービスルーチンを呼び出す時（kernel_cfg.c）は，非
タスクコンテキストで実行されるため問題ない。

(a)のscyc_startと(b)のtwd_startについては，タスクコンテキストから呼び
出す時には，処理途中にタスク切換えが発生するのを避けるために，ディスパッ
チ保留状態にしている。そのため，タスクマイグレーションも抑止されている。

(c)〜(e)の4つの関数は，タイムイベント管理モジュールのコールバックによ
り呼び出される。タイムイベント管理モジュールのコールバックがタスクコン
テキストから呼び出されるのは，次の状況に限られる。

・ext_tsk，ena_dsp，chg_ipmにおいて，ディスパッチ保留状態が解除され，
  保留されていたシステム周期／タイムウィンドウ切換えが行われる時

・システム周期停止モードで呼び出されたchg_somにおいて，システム周期を
  開始する時

この状況は，(a)と(b)の関数が呼び出される状況と一致するため，上記と同じ
理由で問題ない。

参考のために，システム周期とタイムウィンドウ切換え処理と，タイムイベン
ト管理モジュールのコールバックの呼び出し関係を，hrmp3-design.pptxに掲
載する。この図で，scyc_switchからコールバック呼出し経由でscyc_switchが
再帰的に呼び出されるパスがあるように見えるが，scyc_switchはカーネルド
メインのタイムイベントキューにしか登録されず，コールバック呼出し経由で
scyc_switchが呼ばれるのは，コールバックがsignal_timeから呼ばれた場合の
みであるため，再帰呼出しは起こらない。

(g)のloc_spnは，CPUロック状態の一時解除する時には，自プロセッサのPCBへ
のポインタを保持していないため，問題ない。

(h)のacquire_glockは，基本的には，「CPUロックとジャイアントロック」の
節で述べた通り，lock_cpuに続けて呼び出し，get_my_pcbはその後に呼び出す
ため問題ない。タスクコンテキストから呼び出されるacquire_glockで，この
例外になっているのは，(a)〜(e)の関数で一時的にCPUロックを解除した後の
みであり，上で検討済みである。


○データ構造のアクセス元と排他制御

ここでは，グローバルなデータ構造に対して，どのプロセッサがどのタイミン
グでアクセスするのか，その排他制御の方法をまとめる。

●グローバル変数

【システム動作モード管理とシステム周期切換えのための変数】

(1-1) p_global_cursom		現在のシステム動作モード
(1-2) p_global_nxtsom		次のシステム動作モード
(1-3) scycprc_bitmap		システム周期切換えを実行したプロセッサ

これらの変数は，OS初期化時にマスタプロセッサが初期化し，システム周期を
切り換える時に書き換える。p_global_nxtsomは，chg_som内でも書き換える。
CPUロック状態かつジャイアントロック取得状態でアクセスすることで，排他
制御を実現する。

(1-4) scyc_evttim			システム周期を同期させるための変数

この変数は，chg_somで設定し，chg_somから起動要求されるシステム周期開始
ハンドラで参照する。CPUロック状態かつジャイアントロック取得状態でアク
セスすることで，排他制御を実現する。

【システム動作モード管理とシステム周期切換えのための変数】

(1-5) boundary_evttim		境界イベント時刻
(1-6) current_evttim		最後に現在時刻を算出した時点でのイベント時刻
(1-7) current_hrtcnt		最後に現在時刻を算出した時点での高分解能タ
							イマのカウント値
(1-8) monotonic_evttim		最も進んでいた時のイベント時刻
(1-9) systim_offset			システム時刻のオフセット

これらの変数は，OS初期化時にタイムマスタプロセッサが初期化し，現在のイ
ベント時刻を更新する時に書き換える。current_hrtcnt以外は，adj_tim内で
も書き換える。また，systim_offsetは，set_tim内でも書き換える。CPUロッ
ク状態かつジャイアントロック取得状態でアクセスすることで，排他制御を実
現する。

【フック関数へのポインタ】

(1-10) mbfhook_dequeue_wobj
(1-11) mtxhook_release_all
(1-12) mtxhook_scan_ceilmtx
(1-13) mtxhook_check_ceilpri

これらの変数は，OS初期化時にマスタプロセッサが初期化した後，書き換えら
れることはない。よって，排他制御も必要ない。

【ターゲット依存部で使用する変数】

以上に加えて，ARMターゲット依存部では，以下のグローバル変数を用いてい
るが，ここでの分析対象外とする。

() giant_lock
() start_sync
() prc_phase
() sys_phase

●プロセッサ管理ブロック（PCB）

プロセッサ管理ブロック（PCB）は，プロセッサ毎に管理すべき情報を構造体
にまとめたものである。この項で，「自プロセッサ」とはそのPCBが情報を管
理するプロセッサを，「他プロセッサ」とは自プロセッサ以外のプロセッサを
指す。

以下では，PCBの各フィールドについて，初期化と書き込みアクセス箇所，排
他制御方法についてまとめる。

(2-1) prcid					プロセッサID

このフィールドは，OS初期化時に自プロセッサが初期化した後，書き換えられ
ることはない。よって，排他制御も必要ない。

(2-2) p_runtsk				実行状態のタスク

このフィールドは，OS初期化時に自プロセッサが初期化した後，自プロセッサ
のディスパッチャのみが書き換える。このフィールドは，以下の例外を除いて，
自プロセッサのみがアクセスすることができる。以下の例外を除いて，CPUロッ
ク状態でアクセスすることで，排他制御を実現する。

例外）ref_tskにおいて，対象タスクが実行状態か実行可能状態かを判別する
ために，他プロセッサのPCBのp_runtskを参照する。そのため，ref_tskの実行
中に他のプロセッサがp_runtskを書き換えると，対象タスクの古い状態を返す
可能性があるが，これは，排他制御をしていても起こりうることである。統合
仕様書のref_tskの使用上の注意にも，このことを記載しており，古い状態を
返しても問題ない。get_tstについても同様である。

【設計上の考慮】

p_runtskはジャイアントロックを取得せずに書き換えられることから，他プロ
セッサに対するディスパッチ要求が必要かどうかを判定するために，他プロセッ
サのPCBのp_runtskとp_schedtskを比較する方法は採用せず，p_schedtskを変
更したかどうかで判定することとした。具体的には，update_schedtsk_dspに
おいて，変更前のp_schedtskをp_prev_schedtskに保存しておき，変更後の
p_schedtskがそれと一致しない場合のみ，対象プロセッサに対してディスパッ
チを要求割込みを発生させる。

p_runtskとp_schedtskを比較する方法では，次のような問題が考えられる。自
プロセッサが，ジャイアントロックを取得して対象プロセッサのp_schedtskを
書き換えた後に，p_runtskとp_schedtskを比較してディスパッチ要求の要否を
判定する状況を考える。

この時，p_runtskとp_schedtskの比較結果が一致であった直後に，対象プロセッ
サにおいてディスパッチが行われてp_runtskが変更されると，ディスパッチ要
求が抜けてしまうことになる。このようなことは，例えば，同じ優先度を持つ
タスクが2つの場合に，対象プロセッサでrot_rdqした直後に，自プロセッサか
ら対象プロセッサに対してmrot_rdqした場合に起こりうる。

(2-3) p_schedtsk			実行すべきタスク

このフィールドは，OS初期化時に自プロセッサが初期化した後，スケジューラ
が書き換える。以下の例外を除いて，CPUロック状態かつジャイアントロック
取得状態でアクセスすることで，排他制御を実現する。

例外）ディスパッチャ内では，ジャイアントロックを取得せずにこのフィール
ドを参照する。このことから，以下の課題が生じる。

(a) ディスパッチャの実行途中に他のプロセッサがp_schedtskを書き換えた場
合には，書き換え前のp_schedtskにディスパッチするか，書き換え後の
p_schedtskにディスパッチするかが定まらない。ただし，書き換え前の
p_schedtskにディスパッチしても，p_schedtskを書き換えた場合にはプロセッ
サ間割込みを要求し，その後に書き換え後のp_schedtskにディスパッチするこ
とになるため，書き換え前のp_schedtskを実行するのは一時的である。書き換
え前のp_schedtskは，少なくとも書き換え前には実行すべきであったタスクで
あり，一時的に実行されるのは問題ない。

(b) 他のプロセッサのp_schedtskを書き換えると，そのタスクへの切り換えが
即座に発生する可能性がある。そのため，書き換え後のp_schedtskが示すタス
クが，実行開始後にジャイアントロックを取得せずにアクセスするデータにつ
いては，p_schedtskを書き換える前にアクセスを完了しておく必要がある。具
体的には，他のプロセッサ上のタスクを待ち解除する際の対象タスクの待ち情
報ブロックへの書き込みと，メッセージバッファ待ち状態を解除する際のメッ
セージのコピーがこれに該当する。

以上をまとめると，他のプロセッサ上のタスクを待ち解除する際には，対象タ
スクの待ち情報ブロックへの書き込みと，メッセージバッファ機能におけるメッ
セージのコピーを，対象のプロセッサのp_schedtskを待ち解除するタスクの
TCBを指すように書き換える前に行う必要がある。これを逆順で行った場合，
p_schedtskの書き換え直後に対象プロセッサでディスパッチャが実行されると，
待ち情報ブロックが書き換え前の状態になっていて，サービスコールからのリ
ターンパラメータが正しく返らない可能性がある。

このアクセス順序を保証するために，次の3つを行うことが必要である。

(b-1) ソースコード上で，p_schedtskの書き換えを，待ち情報ブロックへの書
き込みやメッセージのコピーよりも後に行う。

(b-2) コンパイラの最適化により，p_schedtskの書き換えが，待ち情報ブロッ
クへの書き込みやメッセージのコピーよりも前に移動されないように，コンパ
イラに伝える。

(b-3) メモリへの書き込み順序が保証されないプロセッサでは，p_schedtskの
書き換えをプログラム上では後に行っていても，実際の書き込み順序が逆にな
る可能性がある。これを避けるために，p_schedtskを書き換える前に，メモリ
バリアを実行する。

(b-2)と(b-3)を実現するために，ターゲット依存部でmemory_barrier関数を用
意し，他プロセッサのp_schedtskを書き換える前に呼び出すこととする。

(2-4) enadsp				ディスパッチ許可状態

このフィールドは，OS初期化時に自プロセッサが初期化した後，dis_dspと
ena_dsp内で書き換える。このフィールドは，自プロセッサのみがアクセスす
ることができる。CPUロック状態でアクセスすることで，排他制御を実現する。

(2-5) dspflg				タスクディスパッチ可能状態

このフィールドは，OS初期化時に自プロセッサが初期化した後，dis_dsp，
ena_dsp，chg_ipm内で書き換える。CPUロック状態かつジャイアントロック取
得状態でアクセスすることで，排他制御を実現する。

(2-6) p_locspn				取得しているスピンロック

このフィールドは，OS初期化時に自プロセッサが初期化した後，loc_spn，
unl_spn，force_unlock_spin内で書き換える。このフィールドは，自プロセッ
サのみがアクセスすることができる。CPUロック状態でアクセスすることで，
排他制御を実現する。

(2-7) target_pcb			プロセッサ管理ブロックのターゲット依存部

このフィールドの扱いは，ターゲット依存である。

(2-8) twdtimer_enable		タイムウィンドウタイマを動作させるべき状態
							であることを示すフラグ

このフィールドは，OS初期化時に自プロセッサが初期化した後，タイムウィン
ドウ管理ルーチン内で書き換える。このフィールドは，自プロセッサのみがア
クセスすることができる。CPUロック状態でアクセスすることで，排他制御を
実現する。

(2-9) rundom				実行中の保護ドメインのビットパターン

このフィールドは，OS初期化時に自プロセッサが初期化した後，ディスパッ
チャ，割込みハンドラの出入口，CPU例外ハンドラの出入口，拡張サービスコー
ルの出入口で書き換える。このフィールドは，自プロセッサのみがアクセスす
ることができる。CPUロック状態でアクセスすることで，排他制御を実現する。

(2-10) kerflg				カーネル動作状態フラグ

このフィールドは，OS初期化時に自プロセッサが初期化した後，OSの終了処理
で書き換える。このフィールドは，自プロセッサのみがアクセスすることがで
きる。CPUロック状態でアクセスすることで，排他制御を実現する。

(2-11) p_cursom				現在のシステム動作モード

このフィールドは，OS初期化時に自プロセッサが初期化した後，システム周期
を切り換える時に書き換える。このフィールドは，自プロセッサのみがアクセ
スすることができる。CPUロック状態でアクセスすることで，排他制御を実現
する。

(2-12) p_runtwd				実行中のタイムウィンドウ

このフィールドは，OS初期化時に自プロセッサが初期化した後，タイムウィン
ドウを切り換える時に書き換える。このフィールドは，自プロセッサのみがア
クセスすることができる。CPUロック状態でアクセスすることで，排他制御を
実現する。

(2-13) left_twdtim			タイムウィンドウの残り時間

このフィールドは，タイムウィンドウ開始時に自プロセッサが初期化した後，
タイムウィンドウ管理ルーチン内で書き換える。このフィールドは，自プロセッ
サのみがアクセスすることができる。CPUロック状態でアクセスすることで，
排他制御を実現する。

(2-14) twdtimer_flag		タイムウィンドウタイマが動作中かを示すフラグ

このフィールドは，OS初期化時に自プロセッサが初期化した後，タイムウィン
ドウ管理ルーチン内で書き換える。このフィールドは，自プロセッサのみがア
クセスすることができる。CPUロック状態でアクセスすることで，排他制御を
実現する。

(2-15) pending_twdswitch	タイムウィンドウ切換え処理を保留しているこ
							とを示すフラグ

このフィールドは，OS初期化時に自プロセッサが初期化した後，タイムウィン
ドウ管理ルーチン内で書き換える。このフィールドは，自プロセッサのみがア
クセスすることができる。CPUロック状態でアクセスすることで，排他制御を
実現する。

(2-16) pending_scycswitch	システム周期切換え処理を保留していることを
							示すフラグ

このフィールドは，OS初期化時に自プロセッサが初期化した後，システム周期
管理ルーチン内で書き換える。このフィールドは，自プロセッサのみがアクセ
スすることができる。CPUロック状態でアクセスすることで，排他制御を実現
する。

(2-17) scyc_tmevtb			システム周期を管理するためのタイムイベント
							ブロック

このフィールドは，OS初期化時に自プロセッサが初期化した後，システム周期
を切り換える時に書き換える。自プロセッサのみがアクセスすることができる。
CPUロック状態でアクセスすることで，排他制御を実現する。

(2-18) p_twdsched			現在スケジューリング単位
(2-19) p_idlesched			アイドル時スケジューリング単位

これらのフィールドは，OS初期化時に自プロセッサが初期化した後，タイムウィ
ンドウを切り換える時に書き換える。CPUロック状態かつジャイアントロック
取得状態でアクセスすることで，排他制御を実現する。

(2-20) p_ctxdom				MMU/MPUに設定されている保護ドメイン

これらのフィールドは，OS初期化時に自プロセッサが初期化した後，ディスパッ
チャで書き換える。自プロセッサのみがアクセスすることができる。CPUロッ
ク状態でアクセスすることで，排他制御を実現する。

(2-21) p_schedcb_kernel		カーネルドメインに対応するスケジューリング
							単位管理ブロックへのポインタ
(2-22) p_schedcb_idle		アイドルドメインに対応するスケジューリング
							単位管理ブロックへのポインタ
(2-23) p_tmevt_heap_kernel	カーネルドメインのタイムイベントヒープ
(2-24) p_tmevt_heap_idle	アイドルドメインのタイムイベントヒープへの
							ポインタ

これらのフィールドは，OS初期化時に自プロセッサが初期化した後，書き換え
られることはない。よって，排他制御も必要ない。

(2-25) in_signal_time		高分解能タイマ割込みの処理中であることを示
							すフラグ

これらのフィールドは，OS初期化時に自プロセッサが初期化した後，高分解能
タイマ割込みの出入口で書き換える。CPUロック状態かつジャイアントロック
取得状態でアクセスすることで，排他制御を実現する。

●タスク管理ブロック（TCB）

タスク管理ブロック（TCB）は，タスクに関する情報を構造体にまとめたもの
である。この項で，「自プロセッサ」とはそのタスクが割り付けられているプ
ロセッサを，「他プロセッサ」とは自プロセッサ以外のプロセッサを指す。

(3-1) task_queue			タスクキュー

このフィールドには，CPUロック状態かつジャイアントロック取得状態でアク
セスすることで，排他制御を実現する。

(3-2) p_tinib				初期化ブロックへのポインタ
(3-3) p_dominib				保護ドメイン初期化ブロック

これらのフィールドは，OS初期化時に初期割付けプロセッサが初期化した後，
書き換えられることはない。よって，排他制御も必要ない。

(3-4) p_schedcb				スケジューリング単位管理ブロック
(3-5) tstat					タスク状態

これらのフィールドには，CPUロック状態かつジャイアントロック取得状態で
アクセスすることで，排他制御を実現する。

(3-6) svclevel				拡張サービスコールのネストレベル

このフィールドは，OS初期化時に初期割付けプロセッサが初期化した後，拡張
サービスコールの出入口処理で書き換えられる。このフィールドは，以下の例
外を除いて，自タスクのみがアクセスすることができる。自タスクのみがアク
セスするため，排他制御は必要ない。

例外）ref_tskにおいて，対象タスクのsvclevelを参照する。そのため，
ref_tskの実行中に他のプロセッサがsvclevelを書き換えると，対象タスクの
古いsvclevelを返す可能性があるが，これは，排他制御をしていても起こりう
ることである。統合仕様書のref_tskの使用上の注意にも，このことを記載し
ており，古いsvclevelを返しても問題ない。

(3-7) bpriority				ベース優先度
(3-8) priority				現在の優先度
(3-9) actque				起動要求キューイング
(3-10) wupque				起床要求キューイング
(3-11) raster				タスク終了要求状態
(3-12) enater				タスク終了許可状態
(3-13) p_lastmtx			最後にロックしたミューテックス

これらのフィールドには，CPUロック状態かつジャイアントロック取得状態で
アクセスすることで，排他制御を実現する。

(3-14) tskctxb				タスクコンテキストブロック

このフィールドは，自プロセッサのみがアクセスすることができる。CPUロッ
ク状態でアクセスすることで，排他制御を実現する。

(3-15) p_pcb				割付けプロセッサのPCB
(3-16) actprc				次回起動時割付けプロセッサ
(3-17) winfo.tmevtb			タイムイベントブロック
(3-18) p_wobjcb				待ちオブジェクトの管理ブロック

これらのフィールドには，CPUロック状態かつジャイアントロック取得状態で
アクセスすることで，排他制御を実現する。

(3-19) winfo.wercd			待ち解除時のエラーコード
(3-20) winfo_obj			オブジェクト毎の待ち情報ブロック

これらのフィールドには，CPUロック状態かつジャイアントロック取得状態で
アクセスすることで排他制御を実現するのが原則である。ただし，タスクが待
ち状態から解除された後は，リターンパラメータを取り出すために，ジャイア
ントロックを取得していない状態でこれらのフィールドを読み出す。そのため，
他のプロセッサ上のタスクを待ち解除する場合には，p_schedtskをそのタスク
を指すように書き換える前に，これらのフィールドを設定しておく必要がある。
詳しくは，「(2-3) p_schedtsk」の項の「(b)」を参照すること。


○サービスコールからのディスパッチ処理

ASP3/HRP3カーネルでは，スケジュール処理を行った後，p_runtskと
p_schedtskが一致していなければ，ディスパッチャを呼び出せば良かった。そ
れに対してFMP3/HRMP3カーネルでは，自プロセッサでディスパッチャを呼び出
すことに加えて，他プロセッサに対してディスパッチ処理を要求する必要があ
る。

複数のタスクの状態を変化させるサービスコールでは，タスクの状態の変更と
スケジュール処理をすべて終えた後に，ディスパッチ処理を行うのが効率が良
い。しかし，どのプロセッサに対してディスパッチ処理を要求する必要がある
かを管理するのは複雑であることから，他プロセッサのp_schedtskを書き換え
た場合には，そのプロセッサに対してディスパッチ処理を要求することとする。
これにより，1つのサービスコールで，同じプロセッサに対して複数回ディス
パッチ処理を要求する可能性があり，ムダな割込みが発生する可能性があるが，
処理をシンプルにするために許容するものとする。

具体的には，p_schedtskの更新とディスパッチの要求を行う関数
（update_schedtsk_dsp）で，他プロセッサのp_schedtskを変更した場合には，
そのプロセッサに対してディスパッチ処理を要求する。

また，「データ構造のアクセス元と排他制御」の章で述べた通り，p_schedtsk
への書き込みは，そのタスクのTCBやそこから指される構造体の値を書き換え
た後にしなければならない。

自プロセッサでのディスパッチャの呼出しは，ASP3/HRP3カーネルと同様，ス
ケジュール処理を行った後，p_runtskとp_schedtskが一致していない場合に呼
び出すものとする。


○タスクのマイグレート処理

●mig_tskによるタスクのマイグレート

mig_tskによりタスクをマイグレートさせる時には，以下の処理を行う必要が
ある。

・TCB中のp_pcb（タスクが割り付けられているプロセッサのPCBへのポインタ）
　とp_schedcb（タスクが属するスケジューリング単位管理ブロックへのポイ
　ンタ）を更新する。

・対象タスクが実行状態の場合，対象タスクのコンテキストをTCBおよびスタッ
　クに保存し，実行可能状態にする。

・対象タスクが実行できる状態の場合，マイグレート元のプロセッサのレディ
　キューから削除し，マイグレート先のプロセッサのレディキューに挿入する。

・対象タスクがタイムアウト付きの待ち状態の場合，マイグレート元のプロセッ
　サのタイムイベントキューから削除し，マイグレート先のプロセッサのタイ
　ムイベントキューに挿入する。

・タスクマイグレーションのトレースログマクロ（LOG_TSKMIG）を呼ぶ。

ここで，対象タスクが実行状態の場合（言い換えると，自タスクをマイグレー
トする場合）には，次の点に注意が必要である。

この場合のマイグレート処理の簡単な実装として，自タスクをマイグレート元
のプロセッサのレディキューから削除し，マイグレート先のプロセッサのレディ
キューに挿入した後，dispatchを呼んでコンテキストを保存する方法が考えら
れる。しかしこの処理順序では，マイグレート先のプロセッサで自タスクが最
高優先順位になる場合，そのプロセッサのPCB内のp_schedtskを自タスクに書
き換えることになるが，その書換え直後にそのプロセッサでディスパッチャが
実行されると，自タスクのコンテキストを保存する前に，コンテキストを復帰
する処理が実行されてしまう恐れがある。また，マイグレート元のプロセッサ
とマイグレート先のプロセッサが，自タスクのスタック領域を同時に使ってし
まうという問題もある。

これらの問題を避けるためには，次の2つを守らなくてはならない。

(1) マイグレート先のプロセッサのPCB内のp_schedtskを書き換えるのは，コ
	ンテキストを保存した後にしなければならない。

(2) マイグレート先のプロセッサのPCB内のp_schedtskを書き換えた後は，タ
	スクのスタック領域を用いてはならない。

(1)を守るためには，dispatchと同様にコンテキストを保存した後に，マイグ
レート先のプロセッサのPCB内のp_schedtskを書き換える必要がある。
p_schedtskを書き換えるのは，make_runnableから呼び出す
update_schedtsk_dspであるため，make_runnableを呼び出すのをコンテキスト
を保存した後とする。また，ジャイアントロックを解放するのは，
make_runnableを呼んだ後とする必要がある。さらに，これらの処理を終えた
後，マイグレート元のプロセッサはexit_and_dispatchを呼び出し，次に実行
すべきタスクに切り換える。(2)を守るために，make_runnableの呼出し以降の
処理を，マイグレート元のプロセッサの非タスクコンテキスト用のスタック
（アイドル処理用のスタックでも良い）を用いて実行することにする。

以上を実現するために，ターゲット依存部にdispatch_and_migrateを，ターゲッ
ト非依存部にmigrate_selfを用意する。

●mact_tskによるタスクのマイグレート

mact_tskにより，プロセッサを指定してタスクを起動する処理は，対象タスク
が休止状態の場合と，そうでない場合で異なる。

対象タスクが休止状態の場合は，TCB中のp_pcb（タスクが割り付けられている
プロセッサのPCBへのポインタ）とp_schedcb（タスクが属するスケジューリン
グ単位管理ブロックへのポインタ）を更新して，対象タスクを起動する。

対象タスクが休止状態でなく，E_QOVRエラーとならない場合には，TCB中の
actque（タスクの起動要求キューイング）をtrueにし，actprc（タスクの次回
起動時割付けプロセッサ）を指定したプロセッサに設定する。この場合，タス
クのマイグレートが起こるのは，タスクが終了した時である。

タスクが終了した時に，TCB中のactqueがtrueになっていれば，以下の処理を
行う必要がある。

・TCB中のactqueをfalseにする。

・TCB中のactprcが設定されていれば（TPRC_NONEでなければ），TCB中のp_pcb
　とp_schedcbを更新する。また，TCB中のactprcの設定を解除する。

・タスクを再起動する。

ここで，自タスクを終了する場合には，mig_tskで自タスクをマイグレートす
る場合と同様の問題があり，それらを避けるために次を守らなくてはならない。

(3) マイグレート先のプロセッサのPCB内のp_schedtskを書き換えた後は，タ
	スクのスタック領域を用いてはならない。

自タスクを終了する時には，自タスクのコンテキストを保存する必要はないた
め，mig_tskの場合の(1)に対応するものはない。

p_schedtskを書き換えるのは，make_activeからmake_runnableを経由して呼び
出すupdate_schedtsk_dspである。また，ジャイアントロックを解放するのは，
make_activeを呼んだ後とする必要がある。さらに，これらの処理を終えた後，
マイグレート元のプロセッサはexit_and_dispatchを呼び出し，次に実行すべ
きタスクに切り換える。(3)を守るために，make_activeの呼出し以降の処理を，
マイグレート元のプロセッサの非タスクコンテキスト用のスタック（アイドル
処理用のスタックでも良い）を用いて実行することにする。

以上を実現するために，ターゲット依存部にexit_and_migrateを，ターゲット
非依存部にmigrate_activate_selfを用意する。


○タスクの待ち情報の持ち方

FMP3/HRMP3カーネルでは，他のタスクのスタックがアクセスできるとは限らな
いことから，タスクの待ち情報とタイムイベントブロックは，TCB中に持つ。
ここでは，TCB中に持つ待ち情報とタイムイベントブロックについて検討する。

待ち状態の実現に必要な情報は，次の2つに分類される。

 (a) 待ち状態を表現する情報
 (b) 待ち解除に伴う返値を表現する情報

この2つが同時に使われることはないため，ASP3カーネルでは，(a)と(b)の一
部をunionを用いて同じ領域に配置している。

ここでは，まず，必要な情報を(a)と(b)に分類する。なお，以下のデータサイ
ズは，intptr_tが32ビット（4バイト）の場合のサイズである。

　・どの待ち状態にも必要なもの
	- wercd（待ち解除時のエラーコード）…(b)				… 4バイト
	- tmevtb（待ち状態用のタイムイベントブロック）…(a) 	… 16バイト
　・同期・通信オブジェクト待ち状態に必要なもの
	- p_wobjcb（待ちオブジェクトの管理ブロック）…(a)		… 4バイト
　・イベントフラグ待ち状態に必要なもの
	- waiptn（待ちパターン／待ち解除時のパターン）…(a)(b)	… 4バイト
	- wfmode（待ちモード）…(a)								… 4バイト
　・データキュー送信待ち状態に必要なもの
	- data（送信データ）…(a)								… 4バイト
　・データキュー受信待ち状態に必要なもの
	- data（受信データ）…(b)								… 4バイト
　・優先度データキュー送信待ち状態に必要なもの
	- data（送信データ）…(a)								… 4バイト
	- datapri（データ優先度）…(a)							… 4バイト
　・優先度データキュー受信待ち状態に必要なもの
	- data（受信データ）…(b)								… 4バイト
	- datapri（データ優先度）…(b)							… 4バイト
　・メッセージバッファ送信待ち状態に必要なもの
	- msg（送信メッセージの格納場所）…(a)					… 4バイト
	- msgsz（送信メッセージサイズ）…(a)					… 4バイト
　・メッセージバッファ受信待ち状態に必要なもの
	- msg（受信メッセージの格納場所）…(a)					… 4バイト
　・固定長メモリプール待ち状態に必要なもの
	- blk（獲得したメモリブロック）…(b)					… 4バイト

(a)と(b)の最大サイズは次の通り。

	(a) 28バイト（＝16+4+8）
	(b) 12バイト（＝4+8）

これを共用体を使わずに実装すると，32バイト（＝20+4+8）となるが，wercd
とtmevtbを共用体として領域を重ねることで，28バイトにすることができる。


○スピンロック機能の実現

●ネイティブスピンロックとエミュレーションによる実現

FMP3/HRMP3カーネルを実装するためには，ターゲットハードウェアは，プロセッ
サ間の排他制御（スピンロック）を実現するための機構を持つことが必要であ
る［NGKI0639］。

プロセッサがアトミック命令を持っている等で，メインメモリ上でスピンロッ
クを実現できるハードウェアでは，実現できるスピンロックの数に（メインメ
モリの容量から来るものを除いて）上限がない。

一方，排他制御を実現するための周辺回路を備えているハードウェアでは，実
現できるスピンロックの数に上限がある場合が多い。統合仕様書では，システ
ムインタフェースレイヤ用（SILスピンロック）とカーネル内部用（ジャイア
ントロック）に，少なくとも2つのスピンロックを実現できることが望ましい
ものとしている［NGKI0640］。カーネルが提供するスピンロック機能には，ハー
ドウェアで実現できるスピンロックの内，SILスピンロックとジャイアントロッ
クに使用するもの以外を使用する。

CRE_SPNによって生成されたスピンロックの数が，ハードウェアで実現できる
スピンロックの内で使用できるものの数を超えた場合には，一部のスピンロッ
クを，ジャイアントロックを用いてエミュレートする［NGKI5170］。これを，
エミュレーションにより実現されたスピンロックと呼び，それ以外のものを，
ネイティブスピンロックと呼ぶ。

ハードウェアで実現できるスピンロックの内でスピンロック機能に使用できる
ものの数（言い換えると，生成できるネイティブスピンロックの最大数）は，
ターゲット依存部で，TMAX_NATIVE_SPNに定義する。ネイティブスピンロック
の数に上限がない場合は，このマクロを定義しない。

コンフィギュレータは，スピンロックのTA_NATIVE属性を参照して，どのスピ
ンロックをネイティブスピンロックとするかを決定する［NGKI5171］。具体的
には，TA_NATIVE属性のスピンロックがTMAX_NATIVE_SPNより多い場合には，エ
ラーを報告する［NGKI5173］。そうでない場合，まず，TA_NATIVE属性のスピ
ンロックをネイティブスピンロックとし［NGKI5172］，ネイティブスピンロッ
クが余った分を，スピンロックIDの小さいものから順にネイティブスピンロッ
クとする。

●スピンロック初期化ブロック

スピンロックに対しては，スピンロック管理ブロックは持たず，スピンロック
初期化ブロックのみを持つ。スピンロック管理ブロックを持たないのは，ター
ゲットハードウェアによっては，ネイティブスピンロックを実現するために，
RAM上のデータ構造が必要ない場合があるためである。

スピンロック初期化ブロックには，スピンロック属性（spnatr），ロック状態
のためのデータ構造（lock），アクセス許可ベクタ（acvct）を持つ。ここで
lockの役割は，スピンロックの実現方法によって異なる。

ネイティブスピンロックで，メインメモリ（RAM）上でスピンロックを実現で
きるハードウェアでは，RAM上のデータ構造を確保した上で，lockには，その
データ構造へのポインタを格納する。

ネイティブスピンロックで，排他制御を実現するための周辺回路を備えている
ハードウェアでは，その周辺回路の識別番号または番地をlockに格納する。こ
の場合，RAM上のデータ構造は必要ない。

ネイティブスピンロックで，上の2つのパターンに当てはまらない場合も考え
られる。その時は，lockの型をターゲット依存で変えられるような改造を考え
ることとする。

エミュレーションにより実現されたスピンロックでは，RAM上に確保した
bool_t型の変数へのポンタを，lockに格納する（これは，現時点では，
Test&Setロックをエミュレーションしているためである。将来的にキューベー
スのアルゴリズムとした場合には見直す）。

●スピンロックの自動解放

ここでは，［NGKI5167］の実現方法について検討する。

NGKI5167：
	タスクが取得したスピンロック（タスクが呼び出した拡張サービスコール
	が取得したスピンロックを含む）を返却せずに終了した場合や，カーネル
	管理の割込みハンドラ，割込みサービスルーチン，タイムイベントハンド
	ラ，カーネル管理のCPU例外ハンドラが取得したスピンロック（これらの
	処理単位が呼び出した拡張サービスコールが取得したスピンロックを含む）
	を返却せずにリターンした場合には，カーネルによってスピンロックが返
	却される．

ここで対象としている処理単位（以下では，カーネル管理の処理単位と呼ぶ）
は，CPUロック解除状態でしか実行開始されない（CPUロック状態で実行開始さ
れたCPU例外ハンドラはカーネル管理外となるため，カーネル管理のCPU例外ハ
ンドラが実行開始される時は，CPUロック解除状態である）。かつ，ここで対
象としていないカーネル管理外の割込みハンドラとCPU例外ハンドラでは，ス
ピンロックを取得できない（スピンロックを取得するサービスコールを呼び出
した場合の動作は保証されない）。

そのため，スピンロックを取得した状態（CPUロック状態になっている）では，
スピンロックを取得できる他の処理単位に切り換わることがなく，カーネル管
理の処理単位の終了時／リターン時に自プロセッサ（処理単位ではないことに
注意せよ）がスピンロックを取得していれば，それはその処理単位がスピンロッ
クを取得したことを意味する。このことから，カーネル管理の処理単位が終了
する際に，自プロセッサがスピンロックを取得していれば，無条件にそれを解
放すれば良い。

これを実現するために，プロセッサ毎にそれが取得しているスピンロックを管
理する。具体的には，PCB中に，そのプロセッサが取得しているスピンロック
を記憶するためのフィールド（p_locspn）を設ける。

また，このフィールドを用いて，自プロセッサがスピンロックを取得していた
場合に，それを強制的に解放する関数force_unlock_spinを実現する。この関
数は，中でCPUロック状態にする必要がないため，CPUロック状態とCPUロック
解除状態のいずれで呼んでも良く，CPUロック状態を解除しない。ただし，処
理途中でマイグレーションしてはならないため，ディスパッチ保留状態で呼ば
なければならないものとする。

以上の考察を踏まえて，［NGKI5167］を実現する方法を，処理単位毎に検討す
る。

・タスク
	スピンロックを取得しているタスク（CPUロック状態になっている）が終
	了するのは，ext_tskを呼び出した場合（タスクのメインルーチンからリ
	ターンした場合を含む）のみである。そこで，ext_tskがCPUロック状態で
	呼び出された場合に，force_unlock_spinを呼び出して，自プロセッサが
	スピンロックを取得していればそれを解放する。

　【バージョン3.1での対応】
	タスクの終了処理を行う関数task_terminateで，対象タスクが自タスクの
	場合は，force_unlock_spinを呼び出して，自プロセッサがスピンロック
	を取得していればそれを解放する。

・カーネル管理の割込みハンドラ
	カーネル管理の割込みハンドラの出口処理で，force_unlock_spinを呼び
	出して，自プロセッサがスピンロックを取得していればそれを解放する。

・割込みサービスルーチン
	割込みサービスルーチンを呼び出した後に，CPUロック状態であれば，
	force_unlock_spinを呼び出して，自プロセッサがスピンロックを取得し
	ていればそれを解放する。ただし，割込みハンドラが呼び出す最後の割込
	みサービスルーチンに対しては，割込みハンドラの出口で同じ処理が行わ
	れるため，この処理を省略することができる。

・タイムイベントハンドラ
	タイムイベントハンドラを呼び出した後に，CPUロック状態であれば，
	force_unlock_spinを呼び出して，自プロセッサがスピンロックを取得し
	ていればそれを解放する。

・カーネル管理のCPU例外ハンドラ
	カーネル管理のCPU例外ハンドラの出口処理で，force_unlock_spinを呼び
	出して，自プロセッサがスピンロックを取得していればそれを解放する。

なお，NGKI5167で，カーネル管理外の割込みハンドラとCPU例外ハンドラが除
外されているのは，これらの処理単位ではスピンロックを取得することができ
ず，リターン時にスピンロックを解放する必要がないためである。

●スピンロック機能とCPUロック状態の管理

スピンロックの取得中はCPUロック状態になるという仕様から，スピンロック
機能とCPUロック状態の管理は，仕様的にも実装的にも絡んでいる。

まず，CPUロック状態／解除状態と，スピンロックを取得している／いない状
態の絡みで，次の3状態が考えられる。

　・UU：CPUロック解除状態 かつ スピンロックを取得していない状態
　・LU：CPUロック状態 かつ スピンロックを取得していない状態
　・LL：CPUロック状態 かつ スピンロックを取得している状態

スピンロックの取得中はCPUロック状態になるという仕様から，「CPUロック解
除状態 かつ スピンロックを取得している状態」はなることはない。

各サービスコールで，この状態は次のように変化する。

							実行するサービスコール
前状態	loc_cpu			unl_cpu			loc_spn			  unl_spn
----------------------------------------------------------------------------
UU		LU［NGKI2730］	UU［NGKI2738］	LL［NGKI2193/4］  E_ILUSE［NGKI2205］
LU		LU［NGKI2731］	UU［NGKI2737］	E_CTX［NGKI2174］ E_ILUSE［NGKI2205］
LL		LL［NGKI2731］	LL［NGKI2739］	E_CTX［NGKI2174］ UU［NGKI2203/4］(*)

なお，(*)において，取得していないスピンロックを返却しようとした場合に
は，E_ILUSEエラーとなる［NGKI2205］。

タスクの終了時と，カーネル管理の割込みハンドラ，割込みサービスルーチン，
タイムイベントハンドラ，カーネル管理のCPU例外ハンドラからのリターン時
には，これらの処理単位が取得したスピンロックは解放される［NGKI5167］。
また，CPUロック解除状態に戻る。そのため，どの状態にあってもUU状態にな
る。

この状態遷移図を，hrmp3-design.pptxに掲載する。


○プロセッサ間割込みの優先度

HRMP3カーネルでは，次の4つの目的でプロセッサ間割込みを使用する。

  - ディスパッチ要求
  - カーネル終了要求
  - 高分解能タイマ設定要求（他のプロセッサの高分解能タイマを設定できな
	い場合のみ）
  - システム周期開始要求

4つのプロセッサ間割込みが使用できない場合は，ターゲット依存部で多重化
する。ただし，多重化したプロセッサ間割込みは，同じ割込み優先度を持つこ
とになる。

まずは，4つのプロセッサ間割込みに自由に優先度を割り付けられると仮定し
て，プロセッサ間割込みの優先度について検討する。

・ディスパッチ要求

他のプロセッサにディスパッチを要求するためのプロセッサ間割込みである。
この割込みによって行う処理は，タスクディスパッチのみである。そのため，
タスクより優先度が高ければ良く，他の割込み処理を阻害しないためには，最
低の割込み優先度にするのが望ましい。

・カーネル終了要求

あるプロセッサでext_kerが呼び出された場合に，他のプロセッサにカーネル
の終了を要求するためのプロセッサ間割込みである。割込み処理の途中や，割
込み優先度マスクが全解除でない状態でもカーネルを終了させるためには，割
込み優先度が高い方が望ましい（ただし，カーネル管理の割込み優先度である
こと）が，カーネルの終了が，割込み処理および割込み優先度マスクが全解除
でない間は遅延することを許容すれば，どの優先度でも問題ない。

・高分解能タイマ設定要求

他のプロセッサに，高分解能タイマの設定値を変更することを要求するための
割込みである。この割込み処理の本体は，CPUロック状態で実行するため，ど
の優先度でも問題ない。ただし，この割込みは，高分解能タイマ割込みが発生
するタイミングを制御するものであるため，高分解能タイマ割込みよりも高い
優先度にしても意味がない。そこで，この割込みの優先度は，高分解能タイマ
割込みと同じにすることを推奨する。

なお，この割込みの優先度を高分解能タイマ割込みより高くする場合には，
set_hrt_event_handlerにおいて，p_my_pcb->in_signal_timeがTRUEの場合に
は，set_hrt_eventを呼ばないようにした方が効率的である。上記の推奨に従
えば，この処理は不必要であるため，このような処理にしていない。

・システム周期開始要求

システム周期停止モードにおいて，あるプロセッサでchg_somが呼び出された
場合に，他のプロセッサにシステム周期の開始を知らせるためのプロセッサ間
割込みである。この割込みによって，システム周期の実行開始処理
（scyc_start）を実行することから，この割込みの優先度は，システム周期割
込み（実装上は，高分解能タイマ割込み）と同じにしなければならない（詳し
い議論は，HRP3カーネルの設計メモを参照すること）。

以上を整理すると，次の通りとなる。

  - ディスパッチ要求：最低の割込み優先度が望ましい
  - カーネル終了要求：高い割込み優先度が望ましいが，どの優先度でも問題ない
  - 高分解能タイマ設定要求：高分解能タイマと同じにすることを推奨する
  - システム周期開始要求：高分解能タイマ割込みと同じにする

1つのプロセッサ間割込みを多重化して用いる場合には，その割込み優先度を，
高分解能タイマ割込みと同じにすればよい。なお，高分解能タイマ割込みの優
先度は，低くすることが望ましいとしている。

2つのプロセッサ間割込みを使える場合には，使用される頻度が高いと思われ
るディスパッチ要求に1つのプロセッサ間割込みを使用し，もう1つを多重化し
て他の3つを実現するのが良いと思われる。

以上
