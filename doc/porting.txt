
		TOPPERS/HRMP3カーネル
		ターゲット依存部 ポーティングガイド

		対応バージョン: Release 3.3.1
		最終更新: 2023年1月4日

このドキュメントは，TOPPERS/HRMP3カーネルを，未サポートのターゲットシ
ステムにポーティングするために必要となるターゲット依存部の実装方法を説
明するものである．現時点では，このドキュメントは未完成である．

○目次

０．本ドキュメントの位置づけ
４．システムインタフェースレイヤ（SIL）のターゲット依存部
	4.1 SILスピンロックの管理
	4.2 プロセッサIDの参照
５．カーネルAPIのターゲット依存部
	5.1 プロセッサとクラス
６．カーネル実装のターゲット依存部
	- プロセッサの識別
	- プロセッサ管理ブロック
	- システム状態の参照用の関数
	- 静的エラーチェック用の関数
	- ジャイアントロック操作
	- ネイティブスピンロック操作
	- スピンロックのエミュレーションによる実現に関する定義
	- マイグレート処理
	- 割込みハンドラの出入口処理
	- CPU例外ハンドラの出入口処理
	- プロセッサ間割込み
		6.x.1 プロセッサ間割込みの登録
		6.x.2 プロセッサ間割込みの要求
	- メモリバリア操作
	- スタートアップモジュール
	- タイマドライバ
	- カーネル実装に関するその他の定義
７．コンフィギュレータ設定ファイルのターゲット依存部
	7.1 設定ファイルとターゲット依存部の位置付け
	7.2 パス2の生成スクリプトのターゲット依存部
		7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数


０．本ドキュメントの位置づけ

TOPPERS/HRMP3カーネルは，TOPPERS/ASP3カーネル（以下，ASP3カーネル）を
拡張したTOPPERS/HRP3カーネル（以下，HRP3カーネル）とTOPPERS/FMP3カーネ
ル（以下，FMP3カーネル）を統合する形で開発したものである．そのため，
HRMP3カーネルを未サポートのターゲットシステムにポーティングする場合に
は，まずASP3カーネル，次にHRP3カーネルまたはFMP3カーネルをポーティング
することを推奨する．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

システムインタフェースレイヤ（SIL）のターゲット依存部は，ASP3/HRP3カー
ネルのものに加えて，以下の定義を追加する必要がある．

4.1 SILスピンロックの管理

SILのターゲット依存部では，SILスピンロックを取得する機能と，全割込みロッ
ク状態へ遷移する機能と，元の状態へ戻す機能（元の状態を記憶するために変
数を使う）を提供する．また，自プロセッサがSILスピンロックを取得してい
る場合に，それを解放する機能を提供する．

(4-1-1) SIL_LOC_SPN()

現在の全割込みロックフラグの状態とSILスピンロックを取得しているかどう
かをSIL_PRE_LOCで定義した変数に保存し，全割込みロック状態に遷移させ，
SILスピンロックを取得するマクロ．全割込みロック解除状態で呼び出された
場合には，SILスピンロックの取得を待ってループしている間に，全割込みロッ
ク状態を解除して割込み要求を受け付けるように実装する．または，割込み要
求があった場合のみ，全割込みロック状態を解除する方法でも良い．

このマクロを実現する際には，ASP3カーネルのポーティングガイドの「1.5 ク
リティカルセクションの出入処理の実現に関する制約」の節に記述されている
制約に従わなければならない．

(4-1-2) SIL_UNL_SPN()

SIL_LOC_SPN()によって変数に保存した状態に戻すマクロ．

このマクロを実現する際には，ASP3カーネルのポーティングガイドの「1.5 ク
リティカルセクションの出入処理の実現に関する制約」の節に記述されている
制約に従わなければならない．

(4-1-3) TOPPERS_sil_force_unl_spn

自プロセッサがSILスピンロックを取得していれば，それを解放する関数．

4.2 プロセッサIDの参照

(4-2-1) void sil_get_pid(ID *p_prcid)

自プロセッサのID番号を参照し，p_prcidで指定したメモリ領域に返す関数．


５．カーネルAPIのターゲット依存部

5.1 プロセッサとクラス

カーネルAPIのターゲット依存部は，ASP3/HRP3カーネルのものに加えて，以下
の定義を追加する必要がある．

(5-1-1) TNUM_PRCID

プロセッサ数に定義するマクロ．

(5-1-2) プロセッサの名称

プロセッサの名称を決め，それぞれをプロセッサID（1から連続する正の整数）
にマクロ定義する．プロセッサの名称の標準は，PRC1，PRC2，…とする．

(5-1-3) TOPPERS_MASTER_PRCID

マスタプロセッサのID番号に定義するマクロ．

(5-1-4) クラスの名称

クラスの名称を決め，それぞれをクラスID（1から連続する正の整数）にマク
ロ定義する．クラスの名称の標準は，"CLS_"に，割付け可能プロセッサを示す
名称，さらに割付け可能プロセッサが複数ある場合には，"_"と初期割付けプ
ロセッサの名称をつなげたものとする．


６．カーネル実装のターゲット依存部

カーネル実装のターゲット依存部は，ASP3/HRP3カーネルのものに加えて，以
下の定義を追加する必要がある．

●プロセッサの識別

(6-x-1) uint_t get_my_prcidx(void)

自プロセッサのインデックス（プロセッサIDから1を引いた値）を返す関数．

(6-x-2) PCB *get_my_pcb(void)（オプション）

自プロセッサのPCB（プロセッサ管理ブロック）へのポインタを返すマクロ．
自プロセッサのPCBへのポインタが効率良く取り出せる場合に定義する．これ
をマクロ定義しない場合，get_my_prcidxを用いて自プロセッサのPCBへのポイ
ンタを求めるマクロが使われる．

(6-x-3) TOPPERS_TMASTER_PRCID（オプション）

タイムマスタプロセッサのID番号に定義するマクロ．このマクロが定義されて
いない場合，マスタプロセッサをタイムマスタプロセッサとする．

●プロセッサ管理ブロック

(6-x-1) TPCB（オプション）

プロセッサ管理ブロックのターゲット依存部のデータ型．

(6-x-2) OMIT_TARGET_PCB（オプション）

プロセッサ管理ブロックのターゲット依存部を使用しない場合に，このシンボ
ルをマクロ定義する．

●システム状態の参照用の関数

(6-x-1) bool_t sense_context(PCB *p_my_pcb)

自プロセッサで実行中の処理単位が，タスクコンテキストで実行されている場
合にはfalse，非タスクコンテキストで実行されている場合にはtrueを返す関
数．この関数は，処理単位がマイグレートしない状態（CPUロック状態，割込
みロック状態，非タスクコンテキスト）で呼び出される．

(6-x-2) bool_t sense_lock(void)

自プロセッサの現在のシステム状態が，CPUロック状態の場合はtrue，CPUロッ
ク解除状態の場合にはfalseを返す関数．

この関数は，処理単位がマイグレートする可能性がある状態で呼び出されるこ
とを考慮して実装しなければならない．例えば，CPUロック状態をPCB中のフィー
ルドで管理する場合には，自プロセッサのPCBの取得からそのフィールドの参
照までを，割込みロック状態にする必要がある．sense_lockをこのように実装
した場合，静的エラーチェック用の関数（check_unl_mystateなど）のデフォ
ルトの定義は効率が悪いものとなる（割込みロック状態への遷移，その解除，
自プロセッサのPCBの取得を，それぞれ2回ずつ実行することになる）ため，ター
ゲット依存部で効率的な実装を用意した方が良い．

●静的エラーチェック用の関数

(6-x-1) OMIT_CHECK_TSKCTX（オプション）
(6-x-2) bool_t check_tskctx(void)（オプション）
(6-x-3) OMIT_CHECK_TSKCTX_MYSTATE（オプション）
(6-x-4) bool_t check_tskctx_mystate(TCB **pp_selftsk, ACPTN *p_selfdom)
														（オプション）

check_tskctxは，呼出しコンテキストがタスクコンテキストである場合に
false，そうでない場合にtrueを返す．check_tskctx_mystateは，それに加え
て，**pp_selftskに自タスクのTCBへのポインタを，*p_selfdomに実行中の保
護ドメインのビットパターンを返す．これらの関数の実行中に，呼び出したタ
スクがマイグレートする可能性があるため，それを考慮して実装する必要があ
る．

いずれの関数も，ターゲット依存部で用意しない場合は，ターゲット非依存部
に含まれる標準の定義が使用される．ターゲット依存部で用意する時は，それ
ぞれ，OMIT_CHECK_TSKCTX，OMIT_CHECK_TSKCTX_MYSTATEをマクロ定義する．

(6-x-5) OMIT_CHECK_UNL_MYSTATE（オプション）
(6-x-6) bool_t check_unl_mystate(TCB **pp_selftsk, ACPTN *p_selfdom,
										bool_t *p_context)（オプション）

check_unl_mystateは，CPUロック解除状態の場合にfalse，そうでない場合に
trueを返す．また，**pp_selftskに自タスクのTCBへのポインタを，
*p_selfdomに実行中の保護ドメインのビットパターンを，contextには呼出し
コンテキスト（タスクコンテキストである場合にfalse，非タスクコンテキス
トである場合にtrue）を返す．これらの関数の実行中に，呼び出したタスクが
マイグレートする可能性があるため，それを考慮して実装する必要がある．

この関数をターゲット依存部で用意しない場合は，ターゲット非依存部に含ま
れる標準の定義が使用される．ターゲット依存部で用意する時は，
OMIT_CHECK_UNL_MYSTATEをマクロ定義する．

(6-x-7) OMIT_CHECK_TSKCTX_UNL（オプション）
(6-x-8) bool_t check_tskctx_unl(void)（オプション）
(6-x-9) OMIT_CHECK_TSKCTX_UNL_MYSTATE（オプション）
(6-x-10) bool_t check_tskctx_unl_mystate(TCB **pp_selftsk, ACPTN *p_selfdom)
														（オプション）

check_tskctx_unlは，呼出しコンテキストがタスクコンテキストかつCPUロッ
ク解除状態の場合にfalse，そうでない場合にtrueを返す．
check_tskctx_unl_mystateは，それに加えて，**pp_selftskに自タスクのTCB
へのポインタを，*p_selfdomに実行中の保護ドメインのビットパターンを返す．
これらの関数の実行中に，呼び出したタスクがマイグレートする可能性がある
ため，それを考慮して実装する必要がある．

いずれの関数も，ターゲット依存部で用意しない場合は，ターゲット非依存部
に含まれる標準の定義が使用される．ターゲット依存部で用意する時は，それ
ぞれ，OMIT_CHECK_TSKCTX_UNL，OMIT_CHECK_TSKCTX_UNL_MYSTATEをマクロ定義
する．

(6-x-11) OMIT_CHECK_DISPATCH（オプション）
(6-x-12) bool_t check_dispatch(void)（オプション）
(6-x-13) OMIT_CHECK_DISPATCH_MYSTATE（オプション）
(6-x-14) bool_t check_dispatch_mystate(TCB **pp_selftsk, ACPTN *p_selfdom)
														（オプション）

check_dispatchは，ディスパッチ保留状態でない場合にfalse，そうでない場
合にtrueを返す．check_tskctx_unl_mystateは，それに加えて，**pp_selftsk
に自タスクのTCBへのポインタを，*p_selfdomに実行中の保護ドメインのビッ
トパターンを返す．これらの関数の実行中に，呼び出したタスクがマイグレー
トする可能性があるため，それを考慮して実装する必要がある．

いずれの関数も，ターゲット依存部で用意しない場合は，ターゲット非依存部
に含まれる標準の定義が使用される．ターゲット依存部で用意する時は，それ
ぞれ，OMIT_CHECK_DISPATCH，OMIT_CHECK_DISPATCH_MYSTATEをマクロ定義する．

(6-x-15) OMIT_CHECK_DISDSP（オプション）
(6-x-16) bool_t check_disdsp(void)（オプション）

check_disdspは，ディスパッチ許可状態の場合にfalse，ディスパッチ禁止状
態の場合にtrueを返す．この関数の実行中に，呼び出したタスクがマイグレー
トする可能性があるため，それを考慮して実装する必要がある．

この関数をターゲット依存部で用意しない場合は，ターゲット非依存部に含ま
れる標準の定義が使用される．ターゲット依存部で用意する時は，
OMIT_CHECK_DISDSPをマクロ定義する．

(6-x-17) OMIT_GET_P_SELFTSK（オプション）
(6-x-18) TCB *get_p_selftsk(void)（オプション）

get_p_selftskは，自タスクのTCBへのポインタを返す．この関数の実行中に，
呼び出したタスクがマイグレートする可能性があるため，それを考慮して実装
する必要がある．

この関数をターゲット依存部で用意しない場合は，ターゲット非依存部に含ま
れる標準の定義が使用される．ターゲット依存部で用意する時は，
OMIT_GET_P_SELFTSKをマクロ定義する．

(6-x-19) OMIT_GET_MYDOM（オプション）
(6-x-20) ACPTN get_mydom(void)（オプション）

get_mydomは，実行中の保護ドメインのビットパターンを返す．この関数の実
行中に，呼び出したタスクがマイグレートする可能性があるため，それを考慮
して実装する必要がある．

この関数をターゲット依存部で用意しない場合は，ターゲット非依存部に含ま
れる標準の定義が使用される．ターゲット依存部で用意する時は，
OMIT_GET_MYDOMをマクロ定義する．

●ジャイアントロック操作

(6-x-1) initialize_glock(void)

ジャイアントロックを初期化する関数．カーネルの初期化時に，マスタプロセッ
サによって呼び出される．

(6-x-2) acquire_glock(void)

ジャイアントロックを取得する関数．CPUロック状態で呼び出され，ジャイア
ントロックの取得を待ってループしている間に，CPUロック状態を解除して割
込み要求を受け付けるように実装する．または，割込み要求があった場合のみ，
CPUロック状態を解除する方法でも良い．

この関数を実現する際には，ASP3カーネルのポーティングガイドの「1.5 クリ
ティカルセクションの出入処理の実現に関する制約」の節に記述されている制
約に従わなければならない．

(6-x-3) release_glock(void)

ジャイアントロックを解放する関数．CPUロック状態で呼び出される．

この関数を実現する際には，ASP3カーネルのポーティングガイドの「1.5 クリ
ティカルセクションの出入処理の実現に関する制約」の節に記述されている制
約に従わなければならない．

●ネイティブスピンロック操作

(6-x-1) TMAX_NATIVE_SPN

スピンロック機能の実現に使用できるネイティブスピンロックの数．ネイティ
ブスピンロックの数に上限がない場合は，このマクロを定義しない．ネイティ
ブスピンロックが使用できない場合には，このマクロを0に定義する．

(6-x-2) void initialize_native_spn(const SPNINIB *p_spninib)

ネイティブスピンロックを初期化する関数．カーネルの初期化時に，マスタプ
ロセッサによって呼び出される．

(6-x-3) void lock_native_spn(const SPNINIB *p_spninib)

ネイティブスピンスピンロックを取得する関数．CPUロック状態で呼び出され，
ネイティブスピンロックの取得を待ってループしている間に，CPUロック状態
を解除して割込み要求を受け付けるように実装する．または，割込み要求があっ
た場合のみ，CPUロック状態を解除する方法でも良い．ネイティブスピンロッ
クを取得していない状態で呼び出され，そうでない状態で呼び出された場合の
動作は保証する必要がない．

この関数を実現する際には，ASP3カーネルのポーティングガイドの「1.5 クリ
ティカルセクションの出入処理の実現に関する制約」の節に記述されている制
約に従わなければならない．

(6-x-4) bool_t try_native_spn(const SPNINIB *p_spninib)

ネイティブスピンロックの取得を試行する関数．ネイティブスピンロックを待
たずに取得できればfalseを，取得できなければtrueを返す．CPUロック状態で
呼び出される．ネイティブスピンロックを取得していない状態で呼び出され，
そうでない状態で呼び出された場合の動作は保証する必要がない．

この関数を実現する際には，ASP3カーネルのポーティングガイドの「1.5 クリ
ティカルセクションの出入処理の実現に関する制約」の節に記述されている制
約に従わなければならない．
       
(6-x-5) void unlock_native_spn(const SPNINIB *p_spninib)

ネイティブスピンロックを解放する関数．CPUロック状態かつネイティブスピ
ンロックを取得した状態で呼び出される．そうでない状態で呼び出された場合
の動作は保証する必要がない．

この関数を実現する際には，ASP3カーネルのポーティングガイドの「1.5 クリ
ティカルセクションの出入処理の実現に関する制約」の節に記述されている制
約に従わなければならない．

(6-x-6) bool_t refer_native_spn(p_spninib)

ネイティブスピンロックのロック状態を参照する関数．ネイティブスピンロッ
クが取得された状態の場合にtrue，そうでない場合にfalseを返す．CPUロック
解除状態で呼び出される．

●スピンロックのエミュレーションによる実現に関する定義

(6-x-1) void delay_for_emulate_spn(void)

スピンロックをエミュレーションにより実現する際に，スピンロックの取得ルー
プ内に入れる遅延処理関数．

●マイグレート処理

(6-x-1) void dispatch_and_migrate(PCB *p_my_pcb, TCB *p_selftsk)

自タスクのマイグレート（dispatch_and_migrate）は，dispatchと同様にコン
テキストを保存した後，スタックを非タスクコンテキスト用スタックに切り換
えて，migrate_selfを呼び出す．具体的な処理内容は次の通り．

----------------------------------------
void
dispatch_and_migrate(PCB *p_my_pcb, TCB *p_selftsk)
{
#ifdef TOPPERS_SUPPORT_OVRHDR
	ovrtimer_stop();				/* オーバランタイマの停止 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
	rundomをスタックに保存する
	スクラッチレジスタを除くすべてのレジスタをスタックに保存する
	if (自タスクがユーザタスク) {
		ユーザスタックポインタをスタックに保存する
	}
	スタックポインタをp_selftskのTCBに保存する
	dispatch_rを，実行再開番地としてp_selftskのTCBに保存する
	スタックを非タスクコンテキスト用スタックに切り換える
	migrate_self(p_my_pcb, p_selftsk);
}
----------------------------------------

(6-x-2) void exit_and_migrate(PCB *p_my_pcb, TCB *p_selftsk)

現在のコンテキストを捨ててマイグレート（exit_and_migrate）は，スタック
を非タスクコンテキスト用スタックに切り換えて，migrate_activate_selfを
呼び出す．具体的な処理内容は次の通り．

----------------------------------------
void
exit_and_migrate(PCB *p_my_pcb, TCB *p_selftsk)
{
	スタックを非タスクコンテキスト用スタックに切り換える
	migrate_activate_self(p_my_pcb, p_selftsk);
}
----------------------------------------

●割込みハンドラの出入口処理

割込みハンドラの出入口処理は，以下を除いてHRP3カーネルと同じである．

・割込みハンドラの出入口処理でアクセスするグローバル変数の内，PCBに含
  めたもの（p_runtsk，p_schedtsk，rundom，twdtimer_enableなど）へのア
  クセスを，PCB中のフィールドへのアクセスに変更する．

・割込みハンドラからリターンした時点で，スピンロックを取得していれば，
  それを解放する．具体的には，割込みハンドラを呼び出した後に，
  force_unlock_spinを呼び出す．

----------------------------------------
#ifdef LOG_INH_ENTER
	log_inh_enter(割込みハンドラ番号);
#endif /* LOG_INH_ENTER */
	割込みハンドラを呼び出す
#ifdef LOG_INH_LEAVE
	log_inh_leave(割込みハンドラ番号);
#endif /* LOG_INH_LEAVE */
+	force_unlock_spin(get_my_pcb());
----------------------------------------

●CPU例外ハンドラの出入口処理

CPU例外ハンドラの出入口処理は，以下を除いてHRP3カーネルと同じである．

・CPU例外ハンドラの出入口処理でアクセスするグローバル変数の内，PCBに含
  めたもの（p_runtsk，p_schedtsk，rundom，twdtimer_enableなど）へのア
  クセスを，PCB中のフィールドへのアクセスに変更する．

・カーネル管理のCPU例外ハンドラからリターンした時点で，スピンロックを
  取得していれば，それを解放する．具体的には，カーネル管理のCPU例外ハ
  ンドラを呼び出した後に，force_unlock_spinを呼び出す．

----------------------------------------
#ifdef LOG_EXC_ENTER
		log_exc_enter(CPU例外ハンドラ番号);
#endif /* LOG_EXC_ENTER */
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
#ifdef LOG_EXC_LEAVE
		log_exc_leave(CPU例外ハンドラ番号);
#endif /* LOG_EXC_LEAVE */
+		force_unlock_spin(get_my_pcb());
----------------------------------------

●プロセッサ間割込み

HRMP3カーネルは，次の4種類のプロセッサ間割込みを用いる．

	- ディスパッチ要求プロセッサ間割込み
	- カーネル終了要求プロセッサ間割込み
	- 高分解能タイマ設定要求プロセッサ間割込み
	- システム周期開始要求プロセッサ間割込み

ここで，高分解能タイマ設定要求プロセッサ間割込みは，他のプロセッサの高
分解能タイマを直接操作できない場合にのみ用いる（他のプロセッサの高分解
能タイマを直接操作できる場合には，TOPPERS_SUPPORT_CONTROL_OTHER_HRTを
マクロ定義する）．

1つのプロセッサ間割込みしか使用できないターゲットでは，それを用いて4種
類のプロセッサ間割込みをエミュレートする必要がある．

6.x.1 プロセッサ間割込みの登録

プロセッサ間割込みを登録するための静的APIを記述したシステムコンフィギュ
レーションファイルを，target_ipi.cfgに用意する．このファイルには，プロ
セッサ間割込みのための割込みハンドラの定義（または，割込みサービスルー
チンの生成）と割込み要求ラインの属性の設定の静的APIを含める．

各プロセッサ間割込みを受け付けた時に呼び出すべきターゲット非依存部の割
込み処理関数は次の通り．

	ディスパッチ要求プロセッサ間割込み			dispatch_handler
	カーネル終了要求プロセッサ間割込み			ext_ker_handler
	高分解能タイマ設定要求プロセッサ間割込み	set_hrt_event_handler
	システム周期開始要求プロセッサ間割込み		start_scyc_handler

ターゲット依存でプロセッサ間割込み要求のクリアなどを行う必要がある場合
には，ターゲット依存部で割込みハンドラ（または，割込みサービスルーチン）
を用意し，それをカーネルに登録する．ターゲット依存の処理が必要ない場合
には，ターゲット非依存部の割込み処理関数を，割込みハンドラ（または，割
込みサービスルーチン）としてカーネルに登録しても良い（その場合は，登録
する関数名に"_kernel_"を付加する必要がある）．

各プロセッサ間割込みの優先度は，以下のように定める．

	ディスパッチ要求プロセッサ間割込み
		- 最低の割込み優先度が望ましい．
	カーネル終了要求プロセッサ間割込み
		- 高い割込み優先度が望ましいが，どの優先度でも問題ない．
	高分解能タイマ設定要求プロセッサ間割込み
		- 高分解能タイマと同じにすることを推奨する．
	システム周期開始要求プロセッサ間割込み
		- 高分解能タイマ割込みと同じにする．

1つのプロセッサ間割込みで，4種類のプロセッサ間割込みをエミュレートする
場合には，その割込み優先度を，高分解能タイマ割込みと同じにする．

6.x.2 プロセッサ間割込みの要求

プロセッサ間割込みを要求する関数を用意する．これらの関数の宣言（インラ
イン関数の場合は定義）は，target_ipi.hに含める．

(6-x-2-1) void request_dispatch_prc(ID prcid)

prcidで指定したプロセッサに対して，ディスパッチ要求プロセッサ間割込み
を要求する関数．

(6-x-2-2) void request_ext_ker(ID prcid)

prcidで指定したプロセッサに対して，カーネル終了要求プロセッサ間割込み
を要求する関数．

(6-x-2-3) void request_set_hrt_event(ID prcid)

prcidで指定したプロセッサに対して，高分解能タイマ設定要求プロセッサ間
割込みを要求する関数．

(6-x-2-4) void request_start_scyc_event(PCB *p_my_pcb)

自プロセッサ以外のすべてのプロセッサに対して，システム周期開始要求プロ
セッサ間割込みを要求する関数．

●メモリバリア操作

(6-x-1) void memory_barrier(void)

メモリバリア操作を行う関数．コンパイラおよびターゲットプロセッサに対し
て，この関数を呼び出すより前のメモリアクセスが，この関数を呼び出した後
のメモリアクセスよりも先に実行されるように指示する．具体的には，次の2
つのことを考慮する必要がある．

(a) コンパイラに対して，この関数の呼び出しの前後でメモリアクセスを移動
	しないように指示する．具体的な方法については，ASP3カーネルのポーティ
	ングガイドの「1.5 クリティカルセクションの出入処理の実現に関する制
	約」の節の(1-5-2)を参照すること．

(b) メモリへのアクセス順序が保証されないプロセッサにおいては，この関数
	を呼び出すより前のメモリアクセスが，この関数を呼び出した後のメモリ
	アクセスよりも先に実行されることを保証するための命令を実行する．

●スタートアップモジュール

スタートアップモジュールは，システムのリセット後に最初に実行されるプロ
グラムである．スタートアップモジュールはカーネルの管理外であり，アプリ
ケーションで用意するのが基本であるが，スタートアップモジュールで行うべ
き処理を明確にするために，プロセッサ依存部またはチップ依存部で，標準の
スタートアップモジュールを用意する.

HRMP3カーネルでは，プロセッサ間で共有するリソースの初期化を担当するプ
ロセッサを，ターゲット定義で1つ定める．これをマスタプロセッサと呼び，
他のプロセッサをスレーブプロセッサと呼ぶ．スタートアップモジュールで行
うべき処理は，マスタプロセッサとスレーブプロセッサで異なる．

マルチプロセッサシステムのリセット時の動作として，リセットによりすべて
のプロセッサが起動されるものと，プロセッサの内の1つ（これをマスタプロ
セッサとするのが自然である）が最初に起動され，そのプロセッサがソフトウェ
アで他のプロセッサを起動するものがある．後者においては，リセット後に他
のプロセッサを起動すれば，その後の振る舞いは前者と同じとなるため，以下
では前者の振る舞いを前提に説明する．

標準のスタートアップモジュールで行うべき処理は，以下の通り．

(a) プロセッサ状態の初期化

各プロセッサにおいて，プロセッサモード，スタックポインタ，フレームポイ
ンタ等，プロセッサの状態を初期化する．また，NMIを除くすべての割込みを
マスクした状態（全割込みロック状態と同等の状態）とする．

DRAMコントローラの初期化など，メモリをアクセスするために必要な初期化処
理を，ここで行ってもよい（次のhardware_init_hookで行ってもよい）．ここ
で，プロセッサ間で共有するリソースの初期化については，いずれか1つのプ
ロセッサ（標準的にはマスタプロセッサ）のみで行うようにする．

(b) hardware_init_hookを呼び出す

各プロセッサにおいて，システムのリセット後すぐに行う必要のあるターゲッ
トシステム依存の初期化処理を行うために，hardware_init_hookを呼び出す．

hardware_init_hookは，ターゲット依存部で用意するのが標準であるが，シス
テムのリセット後すぐに行う必要のある初期化処理を追加するために，アプリ
ケーションで用意したものを用いる場合もある．

アプリケーションおよびターゲット依存部でhardware_init_hookが用意されて
いない場合のために，スタートアップモジュールの中に，何もせずにリターン
するhardware_init_hook関数をweak定義で用意しておく．

メモリアクセスに必要な初期化処理をhardware_init_hookで行う場合には，こ
れを呼び出す時点でメモリにアクセスすることができないため，関数（サブルー
チン）を呼び出すためにスタックを使用するプロセッサでは，戻り番地を汎用
レジスタに入れて呼び出すといった工夫が必要である．この場合，
hardware_init_hookをC言語で記述することはできなくなるが，やむをえない．

なお，プロセッサ間で共有するリソースの初期化については，いずれか1つの
プロセッサ（標準的にはマスタプロセッサ）のみで行うようにする．

(c) bssセクションとdataセクションの初期化（マスタプロセッサのみ）

マスタプロセッサにおいて，ターゲット非依存部で用意している
initialize_sections関数（スタートアップモジュールから呼び出す場合
は，_kernel_initialize_sectionsとする必要がある）を呼び出し，bssセクショ
ンのクリアと，dataセクションの初期値の設定を行う．

ただし，カーネル本体は，kerflg_tableのすべての要素がfalse（＝0）に初期
化されること以外に，これらのセクションが初期化されることに依存していな
い．そのため，スタートアップモジュールをアプリケーションで用意する場合
で，システムサービスやアプリケーションがこれらのセクションが初期化され
ることに依存していない場合には，システムの起動時間を短縮するために，
kerflg_tableの各要素をfalseに初期化するだけで十分である．

(d) software_init_hookを呼び出す（マスタプロセッサのみ）

開発環境（特にライブラリ）に依存して必要な初期化処理を行うために，マス
タプロセッサにおいて，software_init_hookを呼び出す．

software_init_hookは，ターゲット依存部で用意するのが標準である．

ターゲット依存部でsoftware_init_hookが用意されていない場合のために，ス
タートアップモジュールの中に，何もせずにリターンするsoftware_init_hook
関数をweak定義で用意しておく．

(e) target_mprc_initializeを呼び出す（マスタプロセッサのみ）

マスタプロセッサにおいて，カーネルを起動する前に行う必要のあるターゲッ
トシステム依存の初期化処理を行うために，target_mprc_initializeを呼び出
す．

target_mprc_initializeは，ターゲット依存部で用意するのが標準であるが，
システムのリセット後すぐに行う必要のある初期化処理を追加するために，ア
プリケーションで用意したものを用いる場合もある．

(f) プロセッサ間の同期を取る

マスタプロセッサおよびすべてのスレーブプロセッサが，以上の処理を完了す
るまで，待ち合わせる．

(g) sta_kerへ分岐

各プロセッサでsta_kerを呼び出す．sta_kerは，NMIを除くすべての割込みを
マスクした状態（全割込みロック状態と同等の状態）で呼び出さなければなら
ない．sta_kerからはリターンすることがないため，スタートアップモジュー
ルに戻ってくることは考える必要がない．

●タイマドライバ

HRMP3カーネルは，高分解能タイマドライバ，タイムウィンドウタイマドライ
バ，オーバランタイマドライバ（オプション）を用いる．

高分解能タイマは，システム全体で1つの現在値を持ち，指定した時間後に割
込みを発生させる機能は，プロセッサ毎に持っていることを想定している．カー
ネルからは，他のプロセッサの高分解能タイマを操作したい場合があるが，そ
れが可能かどうかはターゲットハードウェアに依存する．他のプロセッサの高
分解能タイマを直接操作できない場合には，プロセッサ間割込みにより，高分
解能タイマの設定を要求する．

タイムウィンドウタイマとオーバランタイマ（オプション）は，プロセッサ毎
に持っていることを想定している．高分解能タイマとは異なり，他のプロセッ
サのタイムウィンドウタイマとオーバランタイマをアクセスすることはないた
め，これらのタイマのドライバの関数は，自プロセッサのタイマを操作するも
のとする．そのため，タイマドライバの関数のパラメータは，HRP3カーネルと
同じである．

以下は，タイマドライバの関数の中で，HRP3カーネルとインタフェースや振舞
いが異なるものについて説明する．

(6-x-1) TOPPERS_SUPPORT_CONTROL_OTHER_HRT

他のプロセッサの高分解能タイマを直接操作できる場合に，このシンボルをマ
クロ定義する．このシンボルをマクロ定義しない場合，以下の3つの関数が，
prcidを自プロセッサ以外のIDとして呼び出されることはない．

(6-x-2) target_hrt_set_event(ID prcid, HRTCNT hrtcnt)

prcidで指定されるプロセッサの高分解能タイマを，hrtcntで指定した値カウ
ントアップしたら割込みを発生させるように設定する．詳しいことは，ASP3カー
ネルのポーティングガイドのこの関数の説明を参照すること．

(6-x-3) target_hrt_clear_event(ID prcid)

prcidで指定されるプロセッサの高分解能タイマを，割込みを発生させないよ
うに設定する．詳しいことは，ASP3カーネルのポーティングガイドのこの関数
の説明を参照すること．

ASP3カーネルとHRP3カーネルでは，この関数はUSE_64BIT_HRTCNTの場合にのみ
用意する必要があるが，HRMP3カーネルでは必ず用意する必要がある．

(6-x-4) target_hrt_raise_event(ID prcid)

prcidで指定されるプロセッサの高分解能タイマ割込みを即座に発生させる．
詳しいことは，ASP3カーネルのポーティングガイドのこの関数の説明を参照す
ること．

●カーネル実装に関するその他の定義

(6-x-x) OMIT_DISPATCH_HANDLER（オプション）

ディスパッチ要求プロセッサ間割込みハンドラ（dispatch_handler）が必要な
い場合には，このシンボルをマクロ定義する．

(6-x-x) OMIT_IDSTACK（オプション）

アイドル処理用のスタック領域を使用しない場合には，このシンボルをマクロ
定義する．


７．コンフィギュレータ設定ファイルのターゲット依存部

HRMP3カーネルのコンフィギュレータ設定ファイルは，HRP3カーネルのものに
対して，拡張を行っている．以下では，HRP3カーネルと異なる点を中心に説明
する．

7.1 設定ファイルとターゲット依存部の位置付け

HRMP3カーネルのコンフィギュレータの設定ファイルは，HRP3カーネルと同様
であるが，パス2の生成スクリプトのターゲット依存部として，
target_kernel.trbに加えて，クラス定義ファイル（target_class.trb）を用
意する必要がある．target_class.trbは，ターゲットでサポートするクラスに
関する情報を定義するスクリプトで，以下の変数を定義する．

(7-1-1) $clsData

ターゲットでサポートするクラスに関する情報を定義する変数．$clsDataは，
クラスID（数値）をキーとし，クラス情報を値とするハッシュである．クラス
情報は，属性名をキーとし，属性値を値とするハッシュである．クラス情報の
属性名:clsidに対しては，クラスのID（数値と名称．カーネルAPIのターゲッ
ト依存部での定義と一致させること）をNumStrクラスのオブジェクトの形で，
属性名:initprcに対しては，初期割付けプロセッサのIDを，属性
名:affinityPrcListに対しては割付け可能プロセッサのリストを設定する．

下の例では，4つのクラスを定義している．クラスIDが1のクラスは，名前が
CLS_ALL_PRC1であり，初期割付けプロセッサがプロセッサ1，割付け可能プロ
セッサがプロセッサ1とプロセッサ2であることを表している．

----------------------------------------
$clsData = {
  1 => { clsid: NumStr.new(1, "CLS_ALL_PRC1"),
         initPrc: 1, affinityPrcList: [ 1,2 ] },
  2 => { clsid: NumStr.new(2, "CLS_ALL_PRC2"),
         initPrc: 2, affinityPrcList: [ 1,2 ] },
  3 => { clsid: NumStr.new(3, "CLS_PRC1"),
         initPrc: 1, affinityPrcList: [ 1 ] },
  4 => { clsid: NumStr.new(4, "CLS_PRC2"),
         initPrc: 2, affinityPrcList: [ 2 ] },
}
----------------------------------------

7.2 パス2の生成スクリプトのターゲット依存部

7.2.1 ターゲット非依存部をインクルードする前に定義すべき変数と関数

(7-2-1-1) $INTNO_VALID		プロセッサ毎の有効な割込み番号のリスト
(7-2-1-2) $INHNO_VALID		プロセッサ毎の有効な割込みハンドラ番号のリスト
(7-2-1-3) $EXCNO_VALID		プロセッサ毎の有効なCPU例外ハンドラ番号のリスト
(7-2-1-4) $INTNO_CREISR_VALID（オプション）	CRE_ISRで使用できるプロセッサ毎
											の割込み番号のリスト
(7-2-1-5) $INHNO_CREISR_VALID（オプション）	CRE_ISRで使用できるプロセッサ毎
											の割込みハンドラ番号のリスト
(7-2-1-6) $EXCNO_DEFEXC_VALID（オプション）	DEF_EXCで使用できるプロセッサ毎
											のCPU例外ハンドラ番号のリスト

これらの変数には，プロセッサID（数値）をキーとし，そのプロセッサで有効
な（または，使用できる）割込み番号／割り込みハンドラ番号／CPU例外ハン
ドラ番号のリストを値とするハッシュを定義する．

(7-2-1-8) DefineVariableSection(genFile, defvar, secname)

defvarで指定される変数定義を，変数がsectionで指定されるセクションに配
置されるように出力する関数．sectionが空文字列の場合には，デフォルトの
セクションに配置する．genFileには，出力先のファイル（GenFileクラス）が
渡される．

(7-2-1-9) DefineFunctionSectionBegin(genFile, deffunc1, deffunc2, secname)
(7-2-1-10) DefineFunctionSectionEnd(genFile)

deffunc1とdeffunc2で指定される関数定義を，関数がsectionで指定されるセ
クションに配置されるように出力するための関数．deffunc1には関数の返値の
型，deffunc2には関数名とパラメータリストが渡される．sectionが空文字列
の場合には，デフォルトのセクションに配置する．また，genFileには，出力
先のファイル（GenFileクラス）が渡される．

DefineFunctionSectionBeginは，関数の本体を出力する前に，関数のヘッダを
出力するために呼び出され，DefineFunctionSectionEndは，関数の本体を出力
した後に呼び出される．DefineFunctionSectionEndは，#pragmaで配置先のセ
クションを切り換えるコンパイラで，デフォルトのセクションに戻すための記
述を出力することを想定している．

(7-2-1-11) SecnameKernelData(cls)	カーネルのデータ領域のセクション名

clsで指定されるクラスに属するカーネルのデータ（具体的には，レディキュー
や各オブジェクトの管理ブロックなど）を配置するセクション名を返す関数．
デフォルトのセクションに配置する場合には，空文字列を返す．

(7-2-1-12) SecnameKernelCode(cls)	カーネルのコード領域のセクション名

clsで指定されるクラスに属するカーネルのコード（具体的には，割込みハン
ドラ）を配置するセクション名を返す関数．デフォルトのセクションに配置す
る場合には，空文字列を返す．

(7-2-1-13) SecnameSystemStack(cls, params)

clsで指定されるクラスに属するシステムスタック領域（タスクのシステムス
タック領域，非タスクコンテキスト用スタック領域，アイドル処理用のスタッ
ク領域）を配置するセクション名を返す関数．paramsには，タスクのシステム
スタック領域の場合にはCRE_TSKのパラメータ情報（ハッシュ），非タスクコ
ンテキスト用スタック領域の場合は:istack，アイドル処理用のスタック領域
の場合は:idstackが渡される．デフォルトのセクションに配置する場合には，
空文字列を返す．

(7-2-1-14) AllocSystemStack(stack, size, secname)（オプション）

システムスタック領域を確保する記述を生成するための関数．stack，size，
secnameにはそれぞれ，割り付けるシステムスタック領域の変数名，丸める前
のサイズ，配置するセクションの名前が渡されるので，システムスタック領域
を確保するコードを生成し，大きい方に丸めたサイズを表す文字列を返す．

(7-2-1-15) AllocUserMempfix(mpf, blkcnt, blksz, secname)（オプション）

固定長メモリプール領域を確保する記述を生成するための関数．mpf，blkcnt，
blksz，secnameにはそれぞれ，割り付ける固定長メモリプール領域の変数名，
ブロック数，丸める前のブロックサイズ，配置するセクションの名前が渡され
るので，固定長メモリプール領域を確保するコードを生成する．

(7-2-1-16) GenerateNativeSpn(params)

ネイティブスピンロックを実現するためのデータ構造をメインメモリ上に取る
ことが必要な場合には，そのデータ構造を生成する記述を出力し，そのデータ
構造へのポインタをintptr_t型にキャストした記述を返す．そのようなデータ
構造が必要ない場合には，ハードウェアで実現されたネイティブスピンロック
の識別情報をintptr_t型にキャストした記述を返す．

paramsにはスピンロックのパラメータ情報（ハッシュ）が渡される．
params[:native]には，0〜TMAX_NATIVE_SPN-1の間の，ネイティブスピンロッ
ク毎にユニークな整数値が格納されている．

TMAX_NATIVE_SPNが0の場合には，この関数を定義する必要がない．

(7-2-1-17) TargetCheckCfgInt(params)（オプション）
(7-2-1-18) TargetCheckDefInh(params)（オプション）
(7-2-1-19) TargetCheckCreIsr(params)（オプション）
(7-2-1-20) TargetCheckDefExc(params)（オプション）

CFG_INT，DEF_INH，CRE_ISR，DEF_EXCのパラメータに対して，ターゲット依存
のエラーチェックを行いたい場合には，エラーチェックを行う関数をこれらの
名称で定義する．paramsには，それぞれの静的APIのパラメータ情報（ハッシュ）
が渡される．

割込みを複数のプロセッサで受け付けることができないターゲットシステムで
は，TargetCheckCreIsrにおいて，割付け可能プロセッサが複数あるクラスの
囲み内にCRE_ISRを記述した場合には，警告メッセージを出し，初期割付けプ
ロセッサのみで割込みを受け付けるように設定する．

(7-2-1-21) TargetCheckCfgInt2(params)（オプション）

CFG_INTのパラメータに対するターゲット依存のエラーチェックで，DEF_INHお
よびCRE_ISRのエラーチェックの後に行いたいものがある場合には，エラーチェッ
クを行う関数をこの名称で定義する．paramsには，CFG_INTIのパラメータ情報
（ハッシュ）が渡される．

割込みを複数のプロセッサで受け付けることができないターゲットシステムで
は，要求ラインが属するクラスの初期割付けプロセッサに設定するようにする．
割付け可能プロセッサが複数あるクラスの囲み内に，対応するDEF_INH／
CRE_ISRがないCFG_INTを記述した場合には，警告メッセージを出し，初期割付
けプロセッサのみで割込みを受け付けるように設定する．

以上
