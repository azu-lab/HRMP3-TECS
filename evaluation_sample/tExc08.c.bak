/*
 * This file was automatically generated by tecsgen.
 * Move and rename like below before editing,
 *   gen/tExc08_templ.c => src/tExc08.c
 * to avoid to be overwritten by tecsgen.
 */
/* #[<PREAMBLE>]#
 * Don't edit the comments between #[<...>]# and #[</...>]#
 * These comment are used by tecsmerege when merging.
 *
 * call port function #_TCPF_#
 * require port: signature:sKernel context:task
 *   ER             getExtendedInformation( intptr_t* p_exinf );
 *   ER             sleep( );
 *   ER             sleepTimeout( TMO timeout );
 *   ER             delay( RELTIM delayTime );
 *   ER             exit( );
 *   ER             disableTerminate( );
 *   ER             enableTerminate( );
 *   bool_t         senseTerminate( );
 *   ER             setTime( SYSTIM systemTime );
 *   ER             getTime( SYSTIM* p_systemTime );
 *   ER             adjustTime( int32_t adjustTime );
 *   HRTCNT         fetchHighResolutionTimer( );
 *   ER             rotateReadyQueue( PRI taskPriority );
 *   ER             multiRotateReadyQueue( ID domainId, PRI taskPriority );
 *   ER             getTaskId( ID* p_taskId );
 *   ER             getLoad( PRI taskPriority, uint_t* p_load );
 *   ER             multiGetLoad( ID domainId, PRI taskPriority, uint_t* p_load );
 *   ER             getNthTask( PRI taskPriority, uint_t nth, ID* p_taskID );
 *   ER             multiGetNthTask( ID domainId, PRI taskPriority, uint_t nth, ID* p_taskID );
 *   ER             lockCpu( );
 *   ER             unlockCpu( );
 *   ER             disableDispatch( );
 *   ER             enableDispatch( );
 *   bool_t         senseContext( );
 *   bool_t         senseLock( );
 *   bool_t         senseDispatch( );
 *   bool_t         senseDispatchPendingState( );
 *   bool_t         senseKernel( );
 *   ER             exitKernel( );
 *   ER             changeInterruptPriorityMask( PRI interruptPriority );
 *   ER             getInterruptPriorityMask( PRI* p_interruptPriority );
 *   ER             getProcessorID( ID* p_prcid );
 * require port: signature:siKernel context:non-task
 *   HRTCNT         ciKernel_fetchHighResolutionTimer( );
 *   ER             ciKernel_rotateReadyQueue( PRI taskPriority );
 *   ER             ciKernel_multiRotateReadyQueue( ID domainId, PRI taskPriority );
 *   ER             ciKernel_getTaskId( ID* p_taskId );
 *   ER             ciKernel_lockCpu( );
 *   ER             ciKernel_unlockCpu( );
 *   bool_t         ciKernel_senseContext( );
 *   bool_t         ciKernel_senseLock( );
 *   bool_t         ciKernel_senseDispatch( );
 *   bool_t         ciKernel_senseDispatchPendingState( );
 *   bool_t         ciKernel_senseKernel( );
 *   ER             ciKernel_exitKernel( );
 *   bool_t         ciKernel_exceptionSenseDispatchPendingState( const void* p_exceptionInformation );
 * call port: cTask signature: sTask context:task
 *   ER             cTask_activate( subscript );
 *   ER             cTask_migrateAndActivate( subscript, ID prcid );
 *   ER_UINT        cTask_cancelActivate( subscript );
 *   ER             cTask_migrate( subscript, ID prcid );
 *   ER             cTask_getTaskState( subscript, STAT* p_tskstat );
 *   ER             cTask_changePriority( subscript, PRI priority );
 *   ER             cTask_changeSubPriority( subscript, uint_t subPriority );
 *   ER             cTask_getPriority( subscript, PRI* p_priority );
 *   ER             cTask_refer( subscript, T_RTSK* pk_taskStatus );
 *   ER             cTask_wakeup( subscript );
 *   ER_UINT        cTask_cancelWakeup( subscript );
 *   ER             cTask_releaseWait( subscript );
 *   ER             cTask_suspend( subscript );
 *   ER             cTask_resume( subscript );
 *   ER             cTask_raiseTerminate( subscript );
 *   ER             cTask_terminate( subscript );
 *       subscript:  0...(NCP_cTask-1)
 * call port: cCyclic signature: sCyclic context:task
 *   ER             cCyclic_start( );
 *   ER             cCyclic_stop( );
 *   ER             cCyclic_refer( T_RCYC* pk_cyclicHandlerStatus );
 * call port: cAlarm signature: sAlarm context:task
 *   ER             cAlarm_start( RELTIM alarmTime );
 *   ER             cAlarm_stop( );
 *   ER             cAlarm_refer( T_RALM* pk_alarmStatus );
 * call port: cSerialPort signature: sSerialPort context:task
 *   ER             cSerialPort_open( );
 *   ER             cSerialPort_close( );
 *   ER_UINT        cSerialPort_read( char* buffer, uint_t length );
 *   ER_UINT        cSerialPort_write( const char* buffer, uint_t length );
 *   ER             cSerialPort_control( uint_t ioControl );
 *   ER             cSerialPort_refer( T_SERIAL_RPOR* pk_rpor );
 * call port: cSysLog signature: sSysLog context:task
 *   ER             cSysLog_write( uint_t priority, const SYSLOG* p_syslog );
 *   ER_UINT        cSysLog_read( SYSLOG* p_syslog );
 *   ER             cSysLog_mask( uint_t logMask, uint_t lowMask );
 *   ER             cSysLog_refer( T_SYSLOG_RLOG* pk_rlog );
 *   ER             cSysLog_flush( );
 * call port: cService signature: sService context:task
 *   ER             cService_migrate( int_t no );
 *   ER             cService_terminate( int_t no );
 *
 * #[</PREAMBLE>]# */

/* Put prototype declaration and/or variale definition here #_PAC_# */
#include "tExc08_tecsgen.h"
#include <kernel.h>
#include <t_syslog.h>
#include <t_stdlib.h>
#include "kernel_cfg.h"
#include "tExc08.h"

/*
 *  サービスコールのエラーのログ出力
 */
Inline void
svc_perror(const char *file, int_t line, const char *expr, ER ercd)
{
    if (ercd < 0) {
        t_perror(LOG_ERROR, file, line, expr, ercd);
    }
}

#define SVC_PERROR(expr)    svc_perror(__FILE__, __LINE__, #expr, (expr))

/*
 *  並行実行されるタスクへのメッセージ領域
 */
char    message[3];

/*
 *  ループ回数
 */
ulong_t	task_loop;		/* タスク内でのループ回数 */

/*
 *  マイグレーション先のプロセッサID
 */
ID target_prcid;

#ifndef E_OK
#define	E_OK	0		/* success */
#define	E_ID	(-18)	/* illegal ID */
#endif

/* #[<ENTRY_PORT>]# eSampleTask
 * entry port: eSampleTask
 * signature:  sTaskBody
 * context:    task
 * entry port array size:  NEP_eSampleTask
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eSampleTask_main
 * name:         eSampleTask_main
 * global_name:  tExc08_eSampleTask_main
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eSampleTask_main(CELLIDX idx, int_t subscript)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	volatile ulong_t   i;
    int_t       n = 0;
    int_t       tskno = subscript +1;
    const char  *graph[] = { "|", "  +", "|+", "    *" };
    char        c;
    ID prcid;


    while (1) {
        getProcessorID(&prcid);
        syslog(LOG_NOTICE, "task%s is running on %d (%03d).   %s",
                                        ATTR_taskName[tskno-1], prcid, ++n, graph[tskno-1]);
        for (i = 0; i < task_loop*750; i++);
        c = message[tskno-1];
        message[tskno-1] = 0;
        switch (c) {
        case 'e':
            syslog(LOG_INFO, "#%d#ext_tsk()", tskno);
            SVC_PERROR(exit());
            assert(0);
        case 's':
            syslog(LOG_INFO, "#%d#slp_tsk()", tskno);
            SVC_PERROR(sleep());
            break;
        case 'S':
            syslog(LOG_INFO, "#%d#tslp_tsk(10000)", tskno);
            SVC_PERROR(sleepTimeout(10000));
            break;
        case 'd':
            syslog(LOG_INFO, "#%d#dly_tsk(10000)", tskno);
            SVC_PERROR(delay(10000));
            break;
        case 'g':
            syslog(LOG_INFO, "#%d#mig_tsk(0, %d)", tskno, target_prcid);
            SVC_PERROR(cTask_migrate(tskno, target_prcid));
            break;
        default:
            break;
        }
    }
}

/* #[<ENTRY_PORT>]# eService
 * entry port: eService
 * signature:  sService
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eService_migrate
 * name:         eService_migrate
 * global_name:  tExc08_eService_migrate
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eService_migrate(CELLIDX idx, int_t no)
{
	ER		ercd = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	ID	prcid;
	getProcessorID(&prcid);
	if(prcid == 1){
		target_prcid = 2;
	}
	else if(prcid == 2){
		target_prcid = 1;
	}

	syslog(LOG_INFO, "#Server task %d : mig_tsk(0x%x, %d)", (int_t) idx, no, target_prcid);
	SVC_PERROR(cTask_migrate(no, target_prcid));
	return(ercd);
}

/* #[<ENTRY_FUNC>]# eService_terminate
 * name:         eService_terminate
 * global_name:  tExc08_eService_terminate
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
ER
eService_terminate(CELLIDX idx, int_t no)
{
	ER		ercd = E_OK;
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		return(E_ID);
	} /* end if VALID_IDX(idx) */

	syslog(LOG_INFO, "#Server task %d : ter_tsk(0x%x)", (int_t) idx, no);
	SVC_PERROR(cTask_terminate(no));

	return(ercd);
}



/* #[<ENTRY_PORT>]# eiCyclicHandler
 * entry port: eiCyclicHandler
 * signature:  siHandlerBody
 * context:    non-task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eiCyclicHandler_main
 * name:         eiCyclicHandler_main
 * global_name:  tExc08_eiCyclicHandler_main
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eiCyclicHandler_main(CELLIDX idx)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

    syslog(LOG_NOTICE, "cyclic_handler start!");
    SVC_PERROR(ciKernel_rotateReadyQueue(HIGH_PRIORITY));
    SVC_PERROR(ciKernel_rotateReadyQueue(MID_PRIORITY));
    SVC_PERROR(ciKernel_rotateReadyQueue(LOW_PRIORITY));
}

/* #[<ENTRY_PORT>]# eiAlarmHandler
 * entry port: eiAlarmHandler
 * signature:  siHandlerBody
 * context:    non-task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eiAlarmHandler_main
 * name:         eiAlarmHandler_main
 * global_name:  tExc08_eiAlarmHandler_main
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eiAlarmHandler_main(CELLIDX idx)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	SVC_PERROR(ciKernel_rotateReadyQueue(HIGH_PRIORITY));
    SVC_PERROR(ciKernel_rotateReadyQueue(MID_PRIORITY));
    SVC_PERROR(ciKernel_rotateReadyQueue(LOW_PRIORITY));
}

/* entry port function #_TEPF_# */
/* #[<ENTRY_PORT>]# eMainTask
 * entry port: eMainTask
 * signature:  sTaskBody
 * context:    task
 * #[</ENTRY_PORT>]# */

/* #[<ENTRY_FUNC>]# eMainTask_main
 * name:         eMainTask_main
 * global_name:  tExc08_eMainTask_main
 * oneway:       false
 * #[</ENTRY_FUNC>]# */
void
eMainTask_main(CELLIDX idx)
{
	CELLCB	*p_cellcb;
	if (VALID_IDX(idx)) {
		p_cellcb = GET_CELLCB(idx);
	}
	else {
		/* Write error processing code here */
	} /* end if VALID_IDX(idx) */

	char   c;
    int_t   tskno = 1;
    ER_UINT ercd;
    PRI     tskpri;
#ifndef TASK_LOOP
    volatile ulong_t    i;
    SYSTIM  stime1, stime2, start, fin, time1;
#endif /* TASK_LOOP */
    T_RTSK rtsk;
    ID prcid;

    SVC_PERROR(cSysLog_mask(LOG_UPTO(LOG_INFO), LOG_UPTO(LOG_EMERG)));
    SVC_PERROR(getProcessorID(&prcid));
    syslog(LOG_NOTICE, "TECS sample program starts on processorID=%d (exinf = %d).", prcid, (int_t) idx);

    /*
     *  シリアルポートの初期化
     *
     *  システムログタスクと同じシリアルポートを使う場合など，シリアル
     *  ポートがオープン済みの場合にはここでE_OBJエラーになるが，支障は
     *  ない．
     */
    ercd = cSerialPort_open();
    if (ercd < 0 && MERCD(ercd) != E_OBJ) {
        syslog(LOG_ERROR, "%s (%d) reported by `serial_opn_por'.",
                                    itron_strerror(ercd), SERCD(ercd));
    }
    SVC_PERROR(cSerialPort_control(IOCTL_CRLF | IOCTL_FCSND | IOCTL_FCRCV));

    /*
     *  ループ回数の設定
     *
     *  TASK_LOOPがマクロ定義されている場合，測定せずに，TASK_LOOPに定
     *  義された値を，タスク内でのループ回数とする．
     *
     *  MEASURE_TWICEがマクロ定義されている場合，1回目の測定結果を捨て
     *  て，2回目の測定結果を使う．1回目の測定は長めの時間が出るため．
     */
#ifdef TASK_LOOP
    task_loop = TASK_LOOP;
#else /* TASK_LOOP */

#ifdef MEASURE_TWICE
    task_loop = LOOP_REF;
    SVC_PERROR(get_tim(&stime1));
    for (i = 0; i < task_loop; i++);
    SVC_PERROR(get_tim(&stime2));
#endif /* MEASURE_TWICE */

    task_loop = LOOP_REF;
    SVC_PERROR(get_tim(&stime1));
    for (i = 0; i < task_loop; i++);
    SVC_PERROR(get_tim(&stime2));
    task_loop = LOOP_REF * 400UL / (stime2 - stime1);
#endif /* TASK_LOOP */

    /*
     *  タスクの起動
     */
//  SVC_PERROR(cTask_activate(1));
//  SVC_PERROR(cTask_activate(2));

	if( ATTR_sampleNo == 2 ){
		SVC_PERROR(sleep());
		//syslog(LOG_INFO, "MainTask %d get up on processorID %d", mainno, prcid);
	}

    /*
     *  メインループ
     */
    do {
        SVC_PERROR(cSerialPort_read(&c, 1));
        switch (c) {
        case 'e':
        case 's':
        case 'S':
        case 'd':
        case 'g':
            message[tskno-1] = c;
            break;
        case '1':
            tskno = 1;
            break;
        case '2':
            tskno = 2;
            break;
        case '3':
            tskno = 3;
            break;
        case '4':
            tskno = 4;
            break;
        case '8':
            target_prcid = 1;
            syslog(LOG_INFO, "select processor %d", target_prcid);
            if(ATTR_sampleNo == 2){
            	SVC_PERROR(cTask_wakeup(0));
				SVC_PERROR(sleep());
			}
            break;
        case '9':
            target_prcid = 2;
            syslog(LOG_INFO, "select processor %d", target_prcid);
            if(ATTR_sampleNo == 1){
            	SVC_PERROR(cTask_wakeup(0));
				SVC_PERROR(sleep());
			}
            break;
        case 'f':
            syslog(LOG_INFO, "#mact_tsk(0x%x, 0x%x)", tskno, target_prcid);
            SVC_PERROR(cTask_migrateAndActivate(tskno, target_prcid));
//            SVC_PERROR(cService_migrate(tskno));
//            SVC_PERROR(cTask_activate(tskno));
            break;
        case 'i':
            SVC_PERROR(get_tim(&start));
            cTask_refer(tskno, &rtsk);
            syslog(LOG_INFO, "rtsk.prcid(%d)", rtsk.prcid);
            SVC_PERROR(cService_migrate(tskno));
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;
        case 't':
        	SVC_PERROR(get_tim(&start));
            cTask_refer(tskno, &rtsk);
            syslog(LOG_INFO, "rtsk.prcid(%d)", rtsk.prcid);
            SVC_PERROR(cService_terminate(tskno));
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;       
        case 'a':
        	SVC_PERROR(get_tim(&start));
            syslog(LOG_INFO, "#act_tsk(%d)", tskno);
            SVC_PERROR(cTask_activate(tskno));
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;
        case 'A':
            syslog(LOG_INFO, "#can_act(%d)", tskno);
            SVC_PERROR(ercd = cTask_cancelActivate(tskno));
            if (ercd >= 0) {
                syslog(LOG_NOTICE, "can_act(%d) returns %d", tskno, ercd);
            }
            break;
        case '>':
        	SVC_PERROR(get_tim(&start));
            syslog(LOG_INFO, "#chg_pri(%d, HIGH_PRIORITY)", tskno);
            SVC_PERROR(cTask_changePriority(tskno, HIGH_PRIORITY));
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;
        case '=':
        	SVC_PERROR(get_tim(&start));
            syslog(LOG_INFO, "#chg_pri(%d, MID_PRIORITY)", tskno);
            SVC_PERROR(cTask_changePriority(tskno, MID_PRIORITY));
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;
        case '<':
        	SVC_PERROR(get_tim(&start));
            syslog(LOG_INFO, "#chg_pri(%d, LOW_PRIORITY)", tskno);
            SVC_PERROR(cTask_changePriority(tskno, LOW_PRIORITY));
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;
        case 'G':
        	SVC_PERROR(get_tim(&start));
            syslog(LOG_INFO, "#get_pri(%d, &tskpri)", tskno);
            SVC_PERROR(ercd = cTask_getPriority(tskno, &tskpri));
            if (ercd >= 0) {
                syslog(LOG_NOTICE, "priority of task %d is %d", tskno, tskpri);
            }
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;
        case 'w':
        	SVC_PERROR(get_tim(&start));
            syslog(LOG_INFO, "#wup_tsk(%d)", tskno);
            SVC_PERROR(cTask_wakeup(tskno));
            SVC_PERROR(get_tim(&fin));
            time1 = fin - start;
            syslog(LOG_INFO,"%d",time1);
            break;
        case 'W':
            syslog(LOG_INFO, "#can_wup(%d)", tskno);
            SVC_PERROR(ercd = cTask_cancelWakeup(tskno));
            if (ercd >= 0) {
                syslog(LOG_NOTICE, "can_wup(%d) returns %d", tskno, ercd);
            }
            break;
        case 'l':
            syslog(LOG_INFO, "#rel_wai(%d)", tskno);
            SVC_PERROR(cTask_releaseWait(tskno));
            break;
        case 'u':
            syslog(LOG_INFO, "#sus_tsk(%d)", tskno);
            SVC_PERROR(cTask_suspend(tskno));
            break;
        case 'm':
            syslog(LOG_INFO, "#rsm_tsk(%d)", tskno);
            SVC_PERROR(cTask_resume(tskno));
            break;
        case 'r':
            syslog(LOG_INFO, "#rot_rdq(three priorities)");
            SVC_PERROR(multiRotateReadyQueue(prcid, HIGH_PRIORITY));
            SVC_PERROR(multiRotateReadyQueue(prcid, MID_PRIORITY));
            SVC_PERROR(multiRotateReadyQueue(prcid, LOW_PRIORITY));
            break;
        case 'c':
            syslog(LOG_INFO, "#sta_cyc(1)");
            SVC_PERROR(cCyclic_start());
            break;
        case 'C':
            syslog(LOG_INFO, "#stp_cyc(1)");
            SVC_PERROR(cCyclic_stop());
            break;
        case 'b':
            syslog(LOG_INFO, "#sta_alm(1, 5000)");
            SVC_PERROR(cAlarm_start(5000000));
            break;
        case 'B':
            syslog(LOG_INFO, "#stp_alm(1)");
            SVC_PERROR(cAlarm_stop());
            break;
        default:
            break;
        }
    } while (c != '\003' && c != 'Q');
    syslog(LOG_NOTICE, "Sample program ends.");
    SVC_PERROR(ciKernel_exitKernel());
    assert(0);
}
